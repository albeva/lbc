//
// Created by Albert Varaksin on 12/02/2026.
//
#pragma once
#include <concepts>
#include <llvm/Support/raw_ostream.h>
using namespace llvm;

template <typename T>
concept Streamable = requires(raw_ostream& os, T t) {
    os << t;
};

/// Simple abstraction to generate C++ code
class Builder final { // NOLINT(*-special-member-functions)
public:
    explicit Builder(raw_ostream& os, const StringRef file, const StringRef ns) // NOLINT(*-easily-swappable-parameters)
    : m_os(os)
    , m_file(file)
    , m_ns(ns) {
        header();
    }

    ~Builder() {
        footer();
    }

    template <std::invocable Func>
    void enumClass(const StringRef name, const StringRef type, Func&& func) {
        m_os << m_space << "enum class " << name << " ";
        if (not type.empty()) {
            m_os << ": " << type << " ";
        }
        indent(true, std::forward<Func>(func));
        m_os << ";\n\n";
    }

    void enumCase(const Streamable auto& name) const {
        m_os << m_space << name << ",\n";
    }

    void enumCase(const Streamable auto& name, const Streamable auto& comment) const {
        commentLine(comment);
        m_os << m_space << name << ",\n";
    }

    template <std::invocable Func>
    void block(const Streamable auto& line, Func&& func) {
        m_os << m_space << line << " ";
        indent(true, std::forward<Func>(func));
        m_os << "\n";
    }

    void line(const Streamable auto& line) {
        m_os << m_space << line << ";\n";
    }

    template <std::invocable Func>
    void indent(const bool scoped, Func&& func) {
        if (scoped) {
            m_os << "{\n";
        }

        m_indent++;
        updateSpace();
        std::invoke(std::forward<Func>(func));
        m_indent--;
        updateSpace();

        if (scoped) {
            m_os << m_space << "}";
        }
    }

    void commentLine(const Streamable auto& comment) const {
        m_os << m_space << "/// " << comment << "\n";
    }

    [[nodiscard]] auto space() const -> const std::string& {
        return m_space;
    }

private:
    void updateSpace() {
        m_space.clear();
        m_space.assign(m_indent * 4, ' ');
    }

    void header() const {
        m_os << "//\n";
        m_os << "// This file is part of lbc project\n";
        m_os << "// https://github.com/albeva/lbc\n";
        m_os << "//\n";
        m_os << "// This file is autogenerated from " << m_file << "\n";
        m_os << "#pragma once\n\n";
        m_os << "namespace " << m_ns << " {\n";
    }

    void footer() const {
        m_os << "} // namespace " << m_ns << "\n";
    }

    raw_ostream& m_os; // NOLINT(*-avoid-const-or-ref-data-members)
    StringRef m_file;
    StringRef m_ns;
    std::size_t m_indent = 0;
    std::string m_space;
};
