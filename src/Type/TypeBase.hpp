//
// This file is part of lbc project
// https://github.com/albeva/lbc
//
// DO NOT MODIFY. This file is AUTO GENERATED.
//
// This file is generated by "lbc-type-base" from "Types.td"
// clang-format off
#pragma once
#include "pch.hpp"
#include "Lexer/TokenKind.hpp"
namespace lbc {

/**
 * Enumerate type kinds
 */
enum class TypeKind : std::uint8_t {
    Void,
    Null,
    Any,
    Bool,
    ZString,
    UByte,
    UShort,
    UInteger,
    ULong,
    Byte,
    Short,
    Integer,
    Long,
    Single,
    Double,
    Pointer,
    Reference,
    Function,
};
/**
 * Base class for types
 */
class TypeBase {
public:
    NO_COPY_AND_MOVE(TypeBase)

    TypeBase() = delete;
    virtual ~TypeBase() = default;

    /// Get underlying type kind
    [[nodiscard]] constexpr auto getKind() const -> TypeKind { return m_kind; }

    // -------------------------------------------------------------------------
    // Basic type queries
    // -------------------------------------------------------------------------

    /// Sentinel types
    [[nodiscard]] constexpr auto isSentinel() const -> bool {
        return m_kind >= TypeKind::Void && m_kind <= TypeKind::Any;
    }
    [[nodiscard]] constexpr auto isVoid() const -> bool { return m_kind == TypeKind::Void; }
    [[nodiscard]] constexpr auto isNull() const -> bool { return m_kind == TypeKind::Null; }
    [[nodiscard]] constexpr auto isAny() const -> bool { return m_kind == TypeKind::Any; }

    /// Primitive types
    [[nodiscard]] constexpr auto isPrimitive() const -> bool {
        return m_kind >= TypeKind::Bool && m_kind <= TypeKind::ZString;
    }
    [[nodiscard]] constexpr auto isBool() const -> bool { return m_kind == TypeKind::Bool; }
    [[nodiscard]] constexpr auto isZString() const -> bool { return m_kind == TypeKind::ZString; }

    /// UnsignedIntegral types
    [[nodiscard]] constexpr auto isUnsignedIntegral() const -> bool {
        return m_kind >= TypeKind::UByte && m_kind <= TypeKind::ULong;
    }
    [[nodiscard]] constexpr auto isUByte() const -> bool { return m_kind == TypeKind::UByte; }
    [[nodiscard]] constexpr auto isUShort() const -> bool { return m_kind == TypeKind::UShort; }
    [[nodiscard]] constexpr auto isUInteger() const -> bool { return m_kind == TypeKind::UInteger; }
    [[nodiscard]] constexpr auto isULong() const -> bool { return m_kind == TypeKind::ULong; }

    /// SignedIntegral types
    [[nodiscard]] constexpr auto isSignedIntegral() const -> bool {
        return m_kind >= TypeKind::Byte && m_kind <= TypeKind::Long;
    }
    [[nodiscard]] constexpr auto isByte() const -> bool { return m_kind == TypeKind::Byte; }
    [[nodiscard]] constexpr auto isShort() const -> bool { return m_kind == TypeKind::Short; }
    [[nodiscard]] constexpr auto isInteger() const -> bool { return m_kind == TypeKind::Integer; }
    [[nodiscard]] constexpr auto isLong() const -> bool { return m_kind == TypeKind::Long; }

    /// FloatingPoint types
    [[nodiscard]] constexpr auto isFloatingPoint() const -> bool {
        return m_kind >= TypeKind::Single && m_kind <= TypeKind::Double;
    }
    [[nodiscard]] constexpr auto isSingle() const -> bool { return m_kind == TypeKind::Single; }
    [[nodiscard]] constexpr auto isDouble() const -> bool { return m_kind == TypeKind::Double; }

    /// Compound types
    [[nodiscard]] constexpr auto isCompound() const -> bool {
        return m_kind >= TypeKind::Pointer && m_kind <= TypeKind::Reference;
    }
    [[nodiscard]] constexpr auto isPointer() const -> bool { return m_kind == TypeKind::Pointer; }
    [[nodiscard]] constexpr auto isReference() const -> bool { return m_kind == TypeKind::Reference; }

    /// Aggregate types
    [[nodiscard]] constexpr auto isAggregate() const -> bool {
        return m_kind == TypeKind::Function;
    }
    [[nodiscard]] constexpr auto isFunction() const -> bool { return m_kind == TypeKind::Function; }

    /**
     * Get keyword TokenKind matching current type, or a std::nullopt
     */
    [[nodiscard]] constexpr auto getTokenKind() const -> std::optional<TokenKind> {
        switch (m_kind) {
            case TypeKind::Bool:
                return TokenKind::Bool;
            case TypeKind::ZString:
                return TokenKind::ZString;
            case TypeKind::UByte:
                return TokenKind::UByte;
            case TypeKind::UShort:
                return TokenKind::UShort;
            case TypeKind::UInteger:
                return TokenKind::UInteger;
            case TypeKind::ULong:
                return TokenKind::ULong;
            case TypeKind::Byte:
                return TokenKind::Byte;
            case TypeKind::Short:
                return TokenKind::Short;
            case TypeKind::Integer:
                return TokenKind::Integer;
            case TypeKind::Long:
                return TokenKind::Long;
            case TypeKind::Single:
                return TokenKind::Single;
            case TypeKind::Double:
                return TokenKind::Double;
            default:
                return std::nullopt;
        }
    }

    /// Is it a built-in (with a keyword) type
    [[nodiscard]] constexpr auto isBuiltin() const -> bool {
        switch (m_kind) {
            case TypeKind::Bool:
            case TypeKind::ZString:
            case TypeKind::UByte:
            case TypeKind::UShort:
            case TypeKind::UInteger:
            case TypeKind::ULong:
            case TypeKind::Byte:
            case TypeKind::Short:
            case TypeKind::Integer:
            case TypeKind::Long:
            case TypeKind::Single:
            case TypeKind::Double:
                return true;
            default:
                return false;
        }
    }

protected:
    explicit constexpr TypeBase(const TypeKind kind)
    : m_kind(kind) { }

private:
    TypeKind m_kind;
};
} // namespace lbc
