//
// This file is part of lbc project
// https://github.com/albeva/lbc
//
// DO NOT MODIFY. This file is AUTO GENERATED.
//
// This file is generated by "lbc-type-factory" from "Types.td"
// clang-format off
#pragma once
#include "pch.hpp"
#include "Type.hpp"
#include "Aggregate.hpp"
#include "Compound.hpp"
#include "Numeric.hpp"
namespace lbc {


/**
 * Factory for retrieving and creating types
 */
class TypeFactoryBase {
public:
    NO_COPY_AND_MOVE(TypeFactoryBase)
    TypeFactoryBase() = default;
    virtual ~TypeFactoryBase() = default;

    // NOLINTBEGIN(*-static-cast-downcast)

    // -------------------------------------------------------------------------
    // Sentinel types
    // -------------------------------------------------------------------------

    [[nodiscard]] auto getVoid() const -> const Type* {
        return getSingleton(TypeKind::Void);
    }

    [[nodiscard]] auto getNull() const -> const Type* {
        return getSingleton(TypeKind::Null);
    }

    [[nodiscard]] auto getAny() const -> const Type* {
        return getSingleton(TypeKind::Any);
    }

    // -------------------------------------------------------------------------
    // Primitive types
    // -------------------------------------------------------------------------

    [[nodiscard]] auto getBool() const -> const Type* {
        return getSingleton(TypeKind::Bool);
    }

    [[nodiscard]] auto getZString() const -> const Type* {
        return getSingleton(TypeKind::ZString);
    }

    // -------------------------------------------------------------------------
    // UnsignedIntegral types
    // -------------------------------------------------------------------------

    [[nodiscard]] auto getUByte() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::UByte));
    }

    [[nodiscard]] auto getUShort() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::UShort));
    }

    [[nodiscard]] auto getUInteger() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::UInteger));
    }

    [[nodiscard]] auto getULong() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::ULong));
    }

    // -------------------------------------------------------------------------
    // SignedIntegral types
    // -------------------------------------------------------------------------

    [[nodiscard]] auto getByte() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::Byte));
    }

    [[nodiscard]] auto getShort() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::Short));
    }

    [[nodiscard]] auto getInteger() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::Integer));
    }

    [[nodiscard]] auto getLong() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::Long));
    }

    // -------------------------------------------------------------------------
    // FloatingPoint types
    // -------------------------------------------------------------------------

    [[nodiscard]] auto getSingle() const -> const TypeFloatingPoint* {
        return static_cast<const TypeFloatingPoint*>(getSingleton(TypeKind::Single));
    }

    [[nodiscard]] auto getDouble() const -> const TypeFloatingPoint* {
        return static_cast<const TypeFloatingPoint*>(getSingleton(TypeKind::Double));
    }

    // NOLINTEND(*-static-cast-downcast)

protected:

    /// Get type from m_singleTypes based on TypeKind
    [[nodiscard]] auto getSingleton(const TypeKind kind) const -> const Type* {
        const auto index = static_cast<std::size_t>(kind);
        return m_singleTypes.at(index);
    }

    /// Set type to m_singleTypes based on TypeKind
    void setSingleton(const Type* type) {
        const auto index = static_cast<std::size_t>(type->getKind());
        m_singleTypes.at(index) = type;
    }

    static constexpr std::size_t COUNT = 15;
    static constexpr std::array<TypeKind, COUNT> kSingleTypeKinds {
        TypeKind::Void,
        TypeKind::Null,
        TypeKind::Any,
        TypeKind::Bool,
        TypeKind::ZString,
        TypeKind::UByte,
        TypeKind::UShort,
        TypeKind::UInteger,
        TypeKind::ULong,
        TypeKind::Byte,
        TypeKind::Short,
        TypeKind::Integer,
        TypeKind::Long,
        TypeKind::Single,
        TypeKind::Double,
    };

private:
    std::array<const Type*, COUNT> m_singleTypes {};
};
} // namespace lbc
