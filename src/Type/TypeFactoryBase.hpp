//
// This file is part of lbc project
// https://github.com/albeva/lbc
//
// DO NOT MODIFY. This file is AUTO GENERATED.
//
// This file is generated by "lbc-type-factory" from "Types.td"
// clang-format off
#pragma once
#include "pch.hpp"
#include "Type.hpp"
#include "Aggregate.hpp"
#include "Compound.hpp"
#include "Numeric.hpp"
#include "Lexer/TokenKind.hpp"
namespace lbc {

/**
 * Generated base class for the type factory.
 * Provides typed getters for singleton types and protected
 * storage for type instances indexed by TypeKind. Subclasses
 * are responsible for allocating and registering types via
 * setSingleton().
 */
class TypeFactoryBase {
public:
    NO_COPY_AND_MOVE(TypeFactoryBase)
    TypeFactoryBase() = default;
    virtual ~TypeFactoryBase() = default;

    // NOLINTBEGIN(*-static-cast-downcast)

    // -------------------------------------------------------------------------
    // Sentinel types
    // -------------------------------------------------------------------------

    [[nodiscard]] auto getVoid() const -> const Type* {
        return getSingleton(TypeKind::Void);
    }

    [[nodiscard]] auto getNull() const -> const Type* {
        return getSingleton(TypeKind::Null);
    }

    [[nodiscard]] auto getAny() const -> const Type* {
        return getSingleton(TypeKind::Any);
    }

    // -------------------------------------------------------------------------
    // Primitive types
    // -------------------------------------------------------------------------

    [[nodiscard]] auto getBool() const -> const Type* {
        return getSingleton(TypeKind::Bool);
    }

    [[nodiscard]] auto getZString() const -> const Type* {
        return getSingleton(TypeKind::ZString);
    }

    // -------------------------------------------------------------------------
    // UnsignedIntegral types
    // -------------------------------------------------------------------------

    [[nodiscard]] auto getUByte() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::UByte));
    }

    [[nodiscard]] auto getUShort() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::UShort));
    }

    [[nodiscard]] auto getUInteger() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::UInteger));
    }

    [[nodiscard]] auto getULong() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::ULong));
    }

    // -------------------------------------------------------------------------
    // SignedIntegral types
    // -------------------------------------------------------------------------

    [[nodiscard]] auto getByte() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::Byte));
    }

    [[nodiscard]] auto getShort() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::Short));
    }

    [[nodiscard]] auto getInteger() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::Integer));
    }

    [[nodiscard]] auto getLong() const -> const TypeIntegral* {
        return static_cast<const TypeIntegral*>(getSingleton(TypeKind::Long));
    }

    // -------------------------------------------------------------------------
    // FloatingPoint types
    // -------------------------------------------------------------------------

    [[nodiscard]] auto getSingle() const -> const TypeFloatingPoint* {
        return static_cast<const TypeFloatingPoint*>(getSingleton(TypeKind::Single));
    }

    [[nodiscard]] auto getDouble() const -> const TypeFloatingPoint* {
        return static_cast<const TypeFloatingPoint*>(getSingleton(TypeKind::Double));
    }

    // NOLINTEND(*-static-cast-downcast)

    /**
     * Get type for given TokenKind or a nullptr
     */
    [[nodiscard]] constexpr auto getType(const TokenKind kind) const -> const Type* {
        switch (kind.value()) {
            case TokenKind::Bool:
                return getBool();
            case TokenKind::ZString:
                return getZString();
            case TokenKind::UByte:
                return getUByte();
            case TokenKind::UShort:
                return getUShort();
            case TokenKind::UInteger:
                return getUInteger();
            case TokenKind::ULong:
                return getULong();
            case TokenKind::Byte:
                return getByte();
            case TokenKind::Short:
                return getShort();
            case TokenKind::Integer:
                return getInteger();
            case TokenKind::Long:
                return getLong();
            case TokenKind::Single:
                return getSingle();
            case TokenKind::Double:
                return getDouble();
            default:
                return nullptr;
        }
    }

protected:
    /**
     * Retrieve a singleton type by its TypeKind.
     */
    [[nodiscard]] auto getSingleton(const TypeKind kind) const -> const Type* {
        const auto index = static_cast<std::size_t>(kind);
        return m_singletons.at(index);
    }

    /**
     * Register a singleton type, indexed by its TypeKind.
     */
    void setSingleton(const Type* type) {
        const auto index = static_cast<std::size_t>(type->getKind());
        m_singletons.at(index) = type;
    }

    /// Number of singleton types
    static constexpr std::size_t COUNT = 15;
    /// TypeKind values for all singleton types
    static constexpr std::array<TypeKind, COUNT> kSingletonKinds {
        TypeKind::Void,
        TypeKind::Null,
        TypeKind::Any,
        TypeKind::Bool,
        TypeKind::ZString,
        TypeKind::UByte,
        TypeKind::UShort,
        TypeKind::UInteger,
        TypeKind::ULong,
        TypeKind::Byte,
        TypeKind::Short,
        TypeKind::Integer,
        TypeKind::Long,
        TypeKind::Single,
        TypeKind::Double,
    };

private:
    /// Storage for singleton type instances, indexed by TypeKind ordinal
    std::array<const Type*, COUNT> m_singletons {};
};
} // namespace lbc
