//
// This file is part of lbc project
// https://github.com/albeva/lbc
//
// DO NOT MODIFY. This file is AUTO GENERATED.
//
// This file is generated by "lbc-ast-visitor" from "Ast.td"
// clang-format off
#pragma once
#include "Ast/Ast.hpp"

namespace lbc {

/**
 * Constrains a visitor parameter to match the exact node type,
 * stripping cv-ref qualifiers before comparison.
 */
template<typename T, typename U>
concept IsNode = std::same_as<std::remove_cvref_t<T>, U>;

/**
 * Common base for all AST visitors.
 * Provides unhandled() helpers for reporting missing accept() overloads during development.
 */
class AstVisitorBase {
public:
    virtual ~AstVisitorBase() = default;

protected:
    /// Report an unhandled node and terminate. Call from a catch-all accept() to flag missing overloads.
    [[noreturn]] static void unhandled(const AstRoot& ast, const std::source_location loc = std::source_location::current()) {
        std::println(
            stderr,
            "Unhandled {} at {}:{}:{} in {}",
            std::string_view(ast.getClassName()),
            loc.file_name(),
            loc.line(),
            loc.column(),
            loc.function_name()
        );
        std::exit(EXIT_FAILURE);
    }

    /// Pointer overload - asserts non-null, then delegates to the reference version.
    [[noreturn]] static void unhandled(const AstRoot* ast, const std::source_location loc = std::source_location::current()) {
        assert(ast != nullptr);
        unhandled(*ast, loc);
    }
};

/**
 * Visitor that dispatches over all concrete AST nodes.
 * 
 * Inherit privately, friend the visitor, and implement accept() handlers.
 * A generic accept(const auto&) catch-all can handle unimplemented nodes.
 * 
 * @code
 * class SampleVisitor final : AstVisitor<> {
 * public:
 *     auto process(const AstRoot& ast) const {
 *         visit(ast);
 *     }
 * 
 * private:
 *     friend AstVisitor;
 * 
 *     void accept(const auto& ast) const {
 *         unhandled(ast);
 *     }
 * 
 *     // void accept(const AstModule& ast) const;
 *     // void accept(const AstBuiltInType& ast) const;
 *     // void accept(const AstStmtList& ast) const;
 *     // void accept(const AstExprStmt& ast) const;
 *     // void accept(const AstDeclareStmt& ast) const;
 *     // void accept(const AstFuncStmt& ast) const;
 *     // void accept(const AstReturnStmt& ast) const;
 *     // void accept(const AstDimStmt& ast) const;
 *     // void accept(const AstAssignStmt& ast) const;
 *     // void accept(const AstIfStmt& ast) const;
 *     // void accept(const AstVarDecl& ast) const;
 *     // void accept(const AstFuncDecl& ast) const;
 *     // void accept(const AstFuncParamDecl& ast) const;
 *     // void accept(const AstVarExpr& ast) const;
 *     // void accept(const AstCallExpr& ast) const;
 *     // void accept(const AstLiteralExpr& ast) const;
 *     // void accept(const AstUnaryExpr& ast) const;
 *     // void accept(const AstBinaryExpr& ast) const;
 * };
 * @endcode
 */
template <typename ReturnType = void>
class AstVisitor : AstVisitorBase {
public:
    /**
     * Dispatch to the appropriate accept() handler based on the node's AstKind.
     */
    constexpr auto visit(this auto& self, IsNode<AstRoot> auto& ast) -> ReturnType {
        switch (ast.getKind()) {
            case AstKind::Module:
                return self.accept(llvm::cast<AstModule>(ast));
            case AstKind::BuiltInType:
                return self.accept(llvm::cast<AstBuiltInType>(ast));
            case AstKind::StmtList:
                return self.accept(llvm::cast<AstStmtList>(ast));
            case AstKind::ExprStmt:
                return self.accept(llvm::cast<AstExprStmt>(ast));
            case AstKind::DeclareStmt:
                return self.accept(llvm::cast<AstDeclareStmt>(ast));
            case AstKind::FuncStmt:
                return self.accept(llvm::cast<AstFuncStmt>(ast));
            case AstKind::ReturnStmt:
                return self.accept(llvm::cast<AstReturnStmt>(ast));
            case AstKind::DimStmt:
                return self.accept(llvm::cast<AstDimStmt>(ast));
            case AstKind::AssignStmt:
                return self.accept(llvm::cast<AstAssignStmt>(ast));
            case AstKind::IfStmt:
                return self.accept(llvm::cast<AstIfStmt>(ast));
            case AstKind::VarDecl:
                return self.accept(llvm::cast<AstVarDecl>(ast));
            case AstKind::FuncDecl:
                return self.accept(llvm::cast<AstFuncDecl>(ast));
            case AstKind::FuncParamDecl:
                return self.accept(llvm::cast<AstFuncParamDecl>(ast));
            case AstKind::VarExpr:
                return self.accept(llvm::cast<AstVarExpr>(ast));
            case AstKind::CallExpr:
                return self.accept(llvm::cast<AstCallExpr>(ast));
            case AstKind::LiteralExpr:
                return self.accept(llvm::cast<AstLiteralExpr>(ast));
            case AstKind::UnaryExpr:
                return self.accept(llvm::cast<AstUnaryExpr>(ast));
            case AstKind::BinaryExpr:
                return self.accept(llvm::cast<AstBinaryExpr>(ast));
            default:
                std::unreachable();
        }
    }
};

/**
 * Visitor for type expression nodes under AstType.
 * 
 * Inherit privately, friend the visitor, and implement accept() handlers.
 * A generic accept(const auto&) catch-all can handle unimplemented nodes.
 * 
 * @code
 * class SampleTypeVisitor final : AstTypeVisitor<> {
 * public:
 *     auto process(const AstType& ast) const {
 *         visit(ast);
 *     }
 * 
 * private:
 *     friend AstTypeVisitor;
 * 
 *     void accept(const auto& ast) const {
 *         unhandled(ast);
 *     }
 * 
 *     // void accept(const AstBuiltInType& ast) const;
 * };
 * @endcode
 */
template <typename ReturnType = void>
class AstTypeVisitor : AstVisitorBase {
public:
    /**
     * Dispatch to the appropriate accept() handler based on the node's AstKind.
     */
    constexpr auto visit(this auto& self, IsNode<AstType> auto& ast) -> ReturnType {
        switch (ast.getKind()) {
            case AstKind::BuiltInType:
                return self.accept(llvm::cast<AstBuiltInType>(ast));
            default:
                std::unreachable();
        }
    }
};

/**
 * Visitor for statement nodes under AstStmt.
 * 
 * Inherit privately, friend the visitor, and implement accept() handlers.
 * A generic accept(const auto&) catch-all can handle unimplemented nodes.
 * 
 * @code
 * class SampleStmtVisitor final : AstStmtVisitor<> {
 * public:
 *     auto process(const AstStmt& ast) const {
 *         visit(ast);
 *     }
 * 
 * private:
 *     friend AstStmtVisitor;
 * 
 *     void accept(const auto& ast) const {
 *         unhandled(ast);
 *     }
 * 
 *     // void accept(const AstStmtList& ast) const;
 *     // void accept(const AstExprStmt& ast) const;
 *     // void accept(const AstDeclareStmt& ast) const;
 *     // void accept(const AstFuncStmt& ast) const;
 *     // void accept(const AstReturnStmt& ast) const;
 *     // void accept(const AstDimStmt& ast) const;
 *     // void accept(const AstAssignStmt& ast) const;
 *     // void accept(const AstIfStmt& ast) const;
 * };
 * @endcode
 */
template <typename ReturnType = void>
class AstStmtVisitor : AstVisitorBase {
public:
    /**
     * Dispatch to the appropriate accept() handler based on the node's AstKind.
     */
    constexpr auto visit(this auto& self, IsNode<AstStmt> auto& ast) -> ReturnType {
        switch (ast.getKind()) {
            case AstKind::StmtList:
                return self.accept(llvm::cast<AstStmtList>(ast));
            case AstKind::ExprStmt:
                return self.accept(llvm::cast<AstExprStmt>(ast));
            case AstKind::DeclareStmt:
                return self.accept(llvm::cast<AstDeclareStmt>(ast));
            case AstKind::FuncStmt:
                return self.accept(llvm::cast<AstFuncStmt>(ast));
            case AstKind::ReturnStmt:
                return self.accept(llvm::cast<AstReturnStmt>(ast));
            case AstKind::DimStmt:
                return self.accept(llvm::cast<AstDimStmt>(ast));
            case AstKind::AssignStmt:
                return self.accept(llvm::cast<AstAssignStmt>(ast));
            case AstKind::IfStmt:
                return self.accept(llvm::cast<AstIfStmt>(ast));
            default:
                std::unreachable();
        }
    }
};

/**
 * Visitor for declaration nodes under AstDecl.
 * 
 * Inherit privately, friend the visitor, and implement accept() handlers.
 * A generic accept(const auto&) catch-all can handle unimplemented nodes.
 * 
 * @code
 * class SampleDeclVisitor final : AstDeclVisitor<> {
 * public:
 *     auto process(const AstDecl& ast) const {
 *         visit(ast);
 *     }
 * 
 * private:
 *     friend AstDeclVisitor;
 * 
 *     void accept(const auto& ast) const {
 *         unhandled(ast);
 *     }
 * 
 *     // void accept(const AstVarDecl& ast) const;
 *     // void accept(const AstFuncDecl& ast) const;
 *     // void accept(const AstFuncParamDecl& ast) const;
 * };
 * @endcode
 */
template <typename ReturnType = void>
class AstDeclVisitor : AstVisitorBase {
public:
    /**
     * Dispatch to the appropriate accept() handler based on the node's AstKind.
     */
    constexpr auto visit(this auto& self, IsNode<AstDecl> auto& ast) -> ReturnType {
        switch (ast.getKind()) {
            case AstKind::VarDecl:
                return self.accept(llvm::cast<AstVarDecl>(ast));
            case AstKind::FuncDecl:
                return self.accept(llvm::cast<AstFuncDecl>(ast));
            case AstKind::FuncParamDecl:
                return self.accept(llvm::cast<AstFuncParamDecl>(ast));
            default:
                std::unreachable();
        }
    }
};

/**
 * Visitor for expression nodes under AstExpr.
 * 
 * Inherit privately, friend the visitor, and implement accept() handlers.
 * A generic accept(const auto&) catch-all can handle unimplemented nodes.
 * 
 * @code
 * class SampleExprVisitor final : AstExprVisitor<> {
 * public:
 *     auto process(const AstExpr& ast) const {
 *         visit(ast);
 *     }
 * 
 * private:
 *     friend AstExprVisitor;
 * 
 *     void accept(const auto& ast) const {
 *         unhandled(ast);
 *     }
 * 
 *     // void accept(const AstVarExpr& ast) const;
 *     // void accept(const AstCallExpr& ast) const;
 *     // void accept(const AstLiteralExpr& ast) const;
 *     // void accept(const AstUnaryExpr& ast) const;
 *     // void accept(const AstBinaryExpr& ast) const;
 * };
 * @endcode
 */
template <typename ReturnType = void>
class AstExprVisitor : AstVisitorBase {
public:
    /**
     * Dispatch to the appropriate accept() handler based on the node's AstKind.
     */
    constexpr auto visit(this auto& self, IsNode<AstExpr> auto& ast) -> ReturnType {
        switch (ast.getKind()) {
            case AstKind::VarExpr:
                return self.accept(llvm::cast<AstVarExpr>(ast));
            case AstKind::CallExpr:
                return self.accept(llvm::cast<AstCallExpr>(ast));
            case AstKind::LiteralExpr:
                return self.accept(llvm::cast<AstLiteralExpr>(ast));
            case AstKind::UnaryExpr:
                return self.accept(llvm::cast<AstUnaryExpr>(ast));
            case AstKind::BinaryExpr:
                return self.accept(llvm::cast<AstBinaryExpr>(ast));
            default:
                std::unreachable();
        }
    }
};

} // namespace lbc
