//
// This file is part of lbc project
// https://github.com/albeva/lbc
//
// DO NOT MODIFY. This file is AUTO GENERATED.
//
// This file is generated by "lbc-ast-visitor" from "Ast.td"
// clang-format off
#pragma once
#include "pch.hpp"
#include "Ast/Ast.hpp"

namespace lbc {

/**
 * Common base for all AST visitors.
 * Provides unhandled() helpers for reporting missing accept() overloads during development.
 */
class AstVisitorBase {
public:
    virtual ~AstVisitorBase() = default;

protected:
    /// Report an unhandled node and terminate. Call from a catch-all accept() to flag missing overloads.
    [[noreturn]] static void unhandled(const AstRoot& ast, const std::source_location& loc = std::source_location::current()) {
        std::println(stderr, "Unhandled {} at {}", ast.getClassName(), loc);
        std::exit(EXIT_FAILURE);
    }

    /// Pointer overload - asserts non-null, then delegates to the reference version.
    [[noreturn]] static void unhandled(const AstRoot* ast, const std::source_location& loc = std::source_location::current()) {
        assert(ast != nullptr);
        unhandled(*ast, loc);
    }
};

/**
 * Visitor that dispatches over all concrete AST nodes.
 * 
 * Inherit privately, friend the visitor, and implement accept() handlers.
 * A generic accept(const auto&) catch-all can handle unimplemented nodes.
 * 
 * @code
 * class SampleVisitor final : AstVisitor<> {
 * public:
 *     auto process(const AstRoot& ast) const {
 *         visit(ast);
 *     }
 * 
 * private:
 *     friend AstVisitor;
 * 
 *     void accept(const auto& ast) const {
 *         unhandled(ast);
 *     }
 * 
 *     // void accept(const AstModule& ast) const;
 *     // void accept(const AstBuiltInType& ast) const;
 *     // void accept(const AstPointerType& ast) const;
 *     // void accept(const AstReferenceType& ast) const;
 *     // void accept(const AstStmtList& ast) const;
 *     // void accept(const AstExprStmt& ast) const;
 *     // void accept(const AstDeclareStmt& ast) const;
 *     // void accept(const AstFuncStmt& ast) const;
 *     // void accept(const AstReturnStmt& ast) const;
 *     // void accept(const AstDimStmt& ast) const;
 *     // void accept(const AstAssignStmt& ast) const;
 *     // void accept(const AstIfStmt& ast) const;
 *     // void accept(const AstVarDecl& ast) const;
 *     // void accept(const AstFuncDecl& ast) const;
 *     // void accept(const AstFuncParamDecl& ast) const;
 *     // void accept(const AstVarExpr& ast) const;
 *     // void accept(const AstCallExpr& ast) const;
 *     // void accept(const AstLiteralExpr& ast) const;
 *     // void accept(const AstUnaryExpr& ast) const;
 *     // void accept(const AstBinaryExpr& ast) const;
 *     // void accept(const AstMemberExpr& ast) const;
 * };
 * @endcode
 */
template <typename ReturnType = void>
class AstVisitor : AstVisitorBase {
public:
    /**
     * Dispatch to the appropriate accept() handler based on the node's AstKind.
     */
    constexpr auto visit(this auto& self, std::derived_from<AstRoot> auto& ast) -> ReturnType {
        switch (ast.getKind()) {
            case AstKind::Module:
                return self.accept(llvm::cast<AstModule>(ast));
            case AstKind::BuiltInType:
                return self.accept(llvm::cast<AstBuiltInType>(ast));
            case AstKind::PointerType:
                return self.accept(llvm::cast<AstPointerType>(ast));
            case AstKind::ReferenceType:
                return self.accept(llvm::cast<AstReferenceType>(ast));
            case AstKind::StmtList:
                return self.accept(llvm::cast<AstStmtList>(ast));
            case AstKind::ExprStmt:
                return self.accept(llvm::cast<AstExprStmt>(ast));
            case AstKind::DeclareStmt:
                return self.accept(llvm::cast<AstDeclareStmt>(ast));
            case AstKind::FuncStmt:
                return self.accept(llvm::cast<AstFuncStmt>(ast));
            case AstKind::ReturnStmt:
                return self.accept(llvm::cast<AstReturnStmt>(ast));
            case AstKind::DimStmt:
                return self.accept(llvm::cast<AstDimStmt>(ast));
            case AstKind::AssignStmt:
                return self.accept(llvm::cast<AstAssignStmt>(ast));
            case AstKind::IfStmt:
                return self.accept(llvm::cast<AstIfStmt>(ast));
            case AstKind::VarDecl:
                return self.accept(llvm::cast<AstVarDecl>(ast));
            case AstKind::FuncDecl:
                return self.accept(llvm::cast<AstFuncDecl>(ast));
            case AstKind::FuncParamDecl:
                return self.accept(llvm::cast<AstFuncParamDecl>(ast));
            case AstKind::VarExpr:
                return self.accept(llvm::cast<AstVarExpr>(ast));
            case AstKind::CallExpr:
                return self.accept(llvm::cast<AstCallExpr>(ast));
            case AstKind::LiteralExpr:
                return self.accept(llvm::cast<AstLiteralExpr>(ast));
            case AstKind::UnaryExpr:
                return self.accept(llvm::cast<AstUnaryExpr>(ast));
            case AstKind::BinaryExpr:
                return self.accept(llvm::cast<AstBinaryExpr>(ast));
            case AstKind::MemberExpr:
                return self.accept(llvm::cast<AstMemberExpr>(ast));
            default:
                std::unreachable();
        }
    }
};

/**
 * Visitor for type expression nodes under AstType.
 * 
 * Inherit privately, friend the visitor, and implement accept() handlers.
 * A generic accept(const auto&) catch-all can handle unimplemented nodes.
 * 
 * @code
 * class SampleTypeVisitor final : AstTypeVisitor<> {
 * public:
 *     auto process(const AstType& ast) const {
 *         visit(ast);
 *     }
 * 
 * private:
 *     friend AstTypeVisitor;
 * 
 *     void accept(const auto& ast) const {
 *         unhandled(ast);
 *     }
 * 
 *     // void accept(const AstBuiltInType& ast) const;
 *     // void accept(const AstPointerType& ast) const;
 *     // void accept(const AstReferenceType& ast) const;
 * };
 * @endcode
 */
template <typename ReturnType = void>
class AstTypeVisitor : AstVisitorBase {
public:
    /**
     * Dispatch to the appropriate accept() handler based on the node's AstKind.
     */
    constexpr auto visit(this auto& self, std::derived_from<AstType> auto& ast) -> ReturnType {
        switch (ast.getKind()) {
            case AstKind::BuiltInType:
                return self.accept(llvm::cast<AstBuiltInType>(ast));
            case AstKind::PointerType:
                return self.accept(llvm::cast<AstPointerType>(ast));
            case AstKind::ReferenceType:
                return self.accept(llvm::cast<AstReferenceType>(ast));
            default:
                std::unreachable();
        }
    }
};

/**
 * Visitor for statement nodes under AstStmt.
 * 
 * Inherit privately, friend the visitor, and implement accept() handlers.
 * A generic accept(const auto&) catch-all can handle unimplemented nodes.
 * 
 * @code
 * class SampleStmtVisitor final : AstStmtVisitor<> {
 * public:
 *     auto process(const AstStmt& ast) const {
 *         visit(ast);
 *     }
 * 
 * private:
 *     friend AstStmtVisitor;
 * 
 *     void accept(const auto& ast) const {
 *         unhandled(ast);
 *     }
 * 
 *     // void accept(const AstStmtList& ast) const;
 *     // void accept(const AstExprStmt& ast) const;
 *     // void accept(const AstDeclareStmt& ast) const;
 *     // void accept(const AstFuncStmt& ast) const;
 *     // void accept(const AstReturnStmt& ast) const;
 *     // void accept(const AstDimStmt& ast) const;
 *     // void accept(const AstAssignStmt& ast) const;
 *     // void accept(const AstIfStmt& ast) const;
 * };
 * @endcode
 */
template <typename ReturnType = void>
class AstStmtVisitor : AstVisitorBase {
public:
    /**
     * Dispatch to the appropriate accept() handler based on the node's AstKind.
     */
    constexpr auto visit(this auto& self, std::derived_from<AstStmt> auto& ast) -> ReturnType {
        switch (ast.getKind()) {
            case AstKind::StmtList:
                return self.accept(llvm::cast<AstStmtList>(ast));
            case AstKind::ExprStmt:
                return self.accept(llvm::cast<AstExprStmt>(ast));
            case AstKind::DeclareStmt:
                return self.accept(llvm::cast<AstDeclareStmt>(ast));
            case AstKind::FuncStmt:
                return self.accept(llvm::cast<AstFuncStmt>(ast));
            case AstKind::ReturnStmt:
                return self.accept(llvm::cast<AstReturnStmt>(ast));
            case AstKind::DimStmt:
                return self.accept(llvm::cast<AstDimStmt>(ast));
            case AstKind::AssignStmt:
                return self.accept(llvm::cast<AstAssignStmt>(ast));
            case AstKind::IfStmt:
                return self.accept(llvm::cast<AstIfStmt>(ast));
            default:
                std::unreachable();
        }
    }
};

/**
 * Visitor for declaration nodes under AstDecl.
 * 
 * Inherit privately, friend the visitor, and implement accept() handlers.
 * A generic accept(const auto&) catch-all can handle unimplemented nodes.
 * 
 * @code
 * class SampleDeclVisitor final : AstDeclVisitor<> {
 * public:
 *     auto process(const AstDecl& ast) const {
 *         visit(ast);
 *     }
 * 
 * private:
 *     friend AstDeclVisitor;
 * 
 *     void accept(const auto& ast) const {
 *         unhandled(ast);
 *     }
 * 
 *     // void accept(const AstVarDecl& ast) const;
 *     // void accept(const AstFuncDecl& ast) const;
 *     // void accept(const AstFuncParamDecl& ast) const;
 * };
 * @endcode
 */
template <typename ReturnType = void>
class AstDeclVisitor : AstVisitorBase {
public:
    /**
     * Dispatch to the appropriate accept() handler based on the node's AstKind.
     */
    constexpr auto visit(this auto& self, std::derived_from<AstDecl> auto& ast) -> ReturnType {
        switch (ast.getKind()) {
            case AstKind::VarDecl:
                return self.accept(llvm::cast<AstVarDecl>(ast));
            case AstKind::FuncDecl:
                return self.accept(llvm::cast<AstFuncDecl>(ast));
            case AstKind::FuncParamDecl:
                return self.accept(llvm::cast<AstFuncParamDecl>(ast));
            default:
                std::unreachable();
        }
    }
};

/**
 * Visitor for expression nodes under AstExpr.
 * 
 * Inherit privately, friend the visitor, and implement accept() handlers.
 * A generic accept(const auto&) catch-all can handle unimplemented nodes.
 * 
 * @code
 * class SampleExprVisitor final : AstExprVisitor<> {
 * public:
 *     auto process(const AstExpr& ast) const {
 *         visit(ast);
 *     }
 * 
 * private:
 *     friend AstExprVisitor;
 * 
 *     void accept(const auto& ast) const {
 *         unhandled(ast);
 *     }
 * 
 *     // void accept(const AstVarExpr& ast) const;
 *     // void accept(const AstCallExpr& ast) const;
 *     // void accept(const AstLiteralExpr& ast) const;
 *     // void accept(const AstUnaryExpr& ast) const;
 *     // void accept(const AstBinaryExpr& ast) const;
 *     // void accept(const AstMemberExpr& ast) const;
 * };
 * @endcode
 */
template <typename ReturnType = void>
class AstExprVisitor : AstVisitorBase {
public:
    /**
     * Dispatch to the appropriate accept() handler based on the node's AstKind.
     */
    constexpr auto visit(this auto& self, std::derived_from<AstExpr> auto& ast) -> ReturnType {
        switch (ast.getKind()) {
            case AstKind::VarExpr:
                return self.accept(llvm::cast<AstVarExpr>(ast));
            case AstKind::CallExpr:
                return self.accept(llvm::cast<AstCallExpr>(ast));
            case AstKind::LiteralExpr:
                return self.accept(llvm::cast<AstLiteralExpr>(ast));
            case AstKind::UnaryExpr:
                return self.accept(llvm::cast<AstUnaryExpr>(ast));
            case AstKind::BinaryExpr:
                return self.accept(llvm::cast<AstBinaryExpr>(ast));
            case AstKind::MemberExpr:
                return self.accept(llvm::cast<AstMemberExpr>(ast));
            default:
                std::unreachable();
        }
    }
};

/**
 * Dispatch over concrete AST nodes using a callable visitor.;
 * 
 * @code
 * const auto visitor = Visitor {
 *     [&](const AstModule& ast) {},
 *     /// Type
 *     [&](const AstBuiltInType& ast) {},
 *     [&](const AstPointerType& ast) {},
 *     [&](const AstReferenceType& ast) {},
 *     /// Stmt
 *     [&](const AstStmtList& ast) {},
 *     [&](const AstExprStmt& ast) {},
 *     [&](const AstDeclareStmt& ast) {},
 *     [&](const AstFuncStmt& ast) {},
 *     [&](const AstReturnStmt& ast) {},
 *     [&](const AstDimStmt& ast) {},
 *     [&](const AstAssignStmt& ast) {},
 *     [&](const AstIfStmt& ast) {},
 *     /// Decl
 *     [&](const AstVarDecl& ast) {},
 *     [&](const AstFuncDecl& ast) {},
 *     [&](const AstFuncParamDecl& ast) {},
 *     /// Expr
 *     [&](const AstVarExpr& ast) {},
 *     [&](const AstCallExpr& ast) {},
 *     [&](const AstLiteralExpr& ast) {},
 *     [&](const AstUnaryExpr& ast) {},
 *     [&](const AstBinaryExpr& ast) {},
 *     [&](const AstMemberExpr& ast) {},
 * };
 * visit(ast, visitor);
 * @endcode
 */
template <typename Callable>
constexpr auto visit(std::derived_from<AstRoot> auto& ast, Callable&& callable) -> decltype(auto) {
    switch (ast.getKind()) {
        case AstKind::Module:
            return std::forward<Callable>(callable)(llvm::cast<AstModule>(ast));
        case AstKind::BuiltInType:
            return std::forward<Callable>(callable)(llvm::cast<AstBuiltInType>(ast));
        case AstKind::PointerType:
            return std::forward<Callable>(callable)(llvm::cast<AstPointerType>(ast));
        case AstKind::ReferenceType:
            return std::forward<Callable>(callable)(llvm::cast<AstReferenceType>(ast));
        case AstKind::StmtList:
            return std::forward<Callable>(callable)(llvm::cast<AstStmtList>(ast));
        case AstKind::ExprStmt:
            return std::forward<Callable>(callable)(llvm::cast<AstExprStmt>(ast));
        case AstKind::DeclareStmt:
            return std::forward<Callable>(callable)(llvm::cast<AstDeclareStmt>(ast));
        case AstKind::FuncStmt:
            return std::forward<Callable>(callable)(llvm::cast<AstFuncStmt>(ast));
        case AstKind::ReturnStmt:
            return std::forward<Callable>(callable)(llvm::cast<AstReturnStmt>(ast));
        case AstKind::DimStmt:
            return std::forward<Callable>(callable)(llvm::cast<AstDimStmt>(ast));
        case AstKind::AssignStmt:
            return std::forward<Callable>(callable)(llvm::cast<AstAssignStmt>(ast));
        case AstKind::IfStmt:
            return std::forward<Callable>(callable)(llvm::cast<AstIfStmt>(ast));
        case AstKind::VarDecl:
            return std::forward<Callable>(callable)(llvm::cast<AstVarDecl>(ast));
        case AstKind::FuncDecl:
            return std::forward<Callable>(callable)(llvm::cast<AstFuncDecl>(ast));
        case AstKind::FuncParamDecl:
            return std::forward<Callable>(callable)(llvm::cast<AstFuncParamDecl>(ast));
        case AstKind::VarExpr:
            return std::forward<Callable>(callable)(llvm::cast<AstVarExpr>(ast));
        case AstKind::CallExpr:
            return std::forward<Callable>(callable)(llvm::cast<AstCallExpr>(ast));
        case AstKind::LiteralExpr:
            return std::forward<Callable>(callable)(llvm::cast<AstLiteralExpr>(ast));
        case AstKind::UnaryExpr:
            return std::forward<Callable>(callable)(llvm::cast<AstUnaryExpr>(ast));
        case AstKind::BinaryExpr:
            return std::forward<Callable>(callable)(llvm::cast<AstBinaryExpr>(ast));
        case AstKind::MemberExpr:
            return std::forward<Callable>(callable)(llvm::cast<AstMemberExpr>(ast));
        default:
            std::unreachable();
    }
}
} // namespace lbc
