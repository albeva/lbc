//
// This file is part of lbc project
// https://github.com/albeva/lbc
//
// This file is generated by "lbc-ast-def" from "Ast.td"
// clang-format off
#pragma once
#include "pch.hpp"
#include "Utilities/LiteralValue.hpp"

namespace lbc {

enum class TokenKind: std::uint8_t;
class Type;

/**
 * Enumerates all concrete AST node kinds.
 * Values are ordered by group for efficient range-based membership checks.
 */
enum class AstKind : std::uint8_t {
    Module,
    BuiltInType,
    PointerType,
    ReferenceType,
    StmtList,
    EmptyStmt,
    DimStmt,
    ExprStmt,
    DeclareStmt,
    ExternStmt,
    AssignStmt,
    FuncStmt,
    ReturnStmt,
    IfStmt,
    ImportDecl,
    VarDecl,
    FuncDecl,
    FuncParamDecl,
    VariableExpr,
    CallExpr,
    LiteralExpr,
    UnaryExpr,
    BinaryExpr,
    CastExpr,
    DereferenceExpr,
    AddressOfExpr,
    MemberExpr,
};

// -----------------------------------------------------------------------------
// Forward Declarations
// -----------------------------------------------------------------------------

class AstRoot;
class AstModule;
class AstType;
class AstBuiltInType;
class AstPointerType;
class AstReferenceType;
class AstStmt;
class AstStmtList;
class AstEmptyStmt;
class AstDimStmt;
class AstExprStmt;
class AstDeclareStmt;
class AstExternStmt;
class AstAssignStmt;
class AstFuncStmt;
class AstReturnStmt;
class AstIfStmt;
class AstDecl;
class AstImportDecl;
class AstVarDecl;
class AstFuncDecl;
class AstFuncParamDecl;
class AstExpr;
class AstVariableExpr;
class AstCallExpr;
class AstLiteralExpr;
class AstUnaryExpr;
class AstBinaryExpr;
class AstCastExpr;
class AstDereferenceExpr;
class AstAddressOfExpr;
class AstMemberExpr;

// -----------------------------------------------------------------------------
// Root nodes
// -----------------------------------------------------------------------------

/**
 * The root AST node
 */
class [[nodiscard]] AstRoot {
public:
    NO_COPY_AND_MOVE(AstRoot)

protected:
    /**
     * Construct an AstRoot node
     */
    constexpr AstRoot(
        const AstKind kind,
        const llvm::SMRange range
    )
    : m_kind(kind)
    , m_range(range) {}

public:
    /// LLVM RTTI support to check if given node is an AstRoot
    [[nodiscard]] static constexpr auto classof(const AstRoot* /* ast */) -> bool {
        return true;
    }

    /// Get the kind discriminator for this node
    [[nodiscard]] constexpr auto getKind() const -> AstKind {
        return m_kind;
    }

    /// Get ast node class name
    [[nodiscard]] constexpr auto getClassName() const -> llvm::StringRef {
        const auto index = static_cast<std::size_t>(m_kind);
        return kClassNames.at(index);
    }

    /// Get the range
    [[nodiscard]] constexpr auto getRange() const -> llvm::SMRange {
        return m_range;
    }

    /// Get the next
    [[nodiscard]] constexpr auto getNext() const -> AstRoot* {
        return m_next;
    }

    /// Set the next
    void setNext(AstRoot* next) {
        m_next = next;
    }

private:
    AstKind m_kind;
    llvm::SMRange m_range;
    AstRoot* m_next = nullptr;
    static constexpr std::array<llvm::StringRef, 27> kClassNames {
        "AstModule",
        "AstBuiltInType",
        "AstPointerType",
        "AstReferenceType",
        "AstStmtList",
        "AstEmptyStmt",
        "AstDimStmt",
        "AstExprStmt",
        "AstDeclareStmt",
        "AstExternStmt",
        "AstAssignStmt",
        "AstFuncStmt",
        "AstReturnStmt",
        "AstIfStmt",
        "AstImportDecl",
        "AstVarDecl",
        "AstFuncDecl",
        "AstFuncParamDecl",
        "AstVariableExpr",
        "AstCallExpr",
        "AstLiteralExpr",
        "AstUnaryExpr",
        "AstBinaryExpr",
        "AstCastExpr",
        "AstDereferenceExpr",
        "AstAddressOfExpr",
        "AstMemberExpr"
    };
};

/**
 * Program module node
 */
class [[nodiscard]] AstModule final : public AstRoot {
public:
    /**
     * Construct an AstModule node
     */
    constexpr AstModule(
        const llvm::SMRange range,
        const std::span<AstImportDecl*> imports,
        AstStmtList* stmtList
    )
    : AstRoot(AstKind::Module, range)
    , m_imports(imports)
    , m_stmtList(stmtList) {}

    /// LLVM RTTI support to check if given node is an AstModule
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::Module;
    }

    /// Get the imports
    [[nodiscard]] constexpr auto getImports() const -> std::span<AstImportDecl*> {
        return m_imports;
    }

    /// Get the stmtList
    [[nodiscard]] constexpr auto getStmtList() const -> AstStmtList* {
        return m_stmtList;
    }

    /// Get the implicitMain
    [[nodiscard]] constexpr auto getImplicitMain() const -> bool {
        return m_implicitMain;
    }

    /// Set the implicitMain
    void setImplicitMain(const bool implicitMain) {
        m_implicitMain = implicitMain;
    }

private:
    std::span<AstImportDecl*> m_imports;
    AstStmtList* m_stmtList;
    bool m_implicitMain = false;
};

// -----------------------------------------------------------------------------
// Type nodes
// -----------------------------------------------------------------------------

/**
 * Abstract base for all type expression nodes
 */
class [[nodiscard]] AstType : public AstRoot {
protected:
    using AstRoot::AstRoot;

public:
    /// LLVM RTTI support to check if given node is an AstType
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() >= AstKind::BuiltInType && ast->getKind() <= AstKind::ReferenceType;
    }

    /// Get the type
    [[nodiscard]] constexpr auto getType() const -> const Type* {
        return m_type;
    }

    /// Set the type
    void setType(const Type* type) {
        m_type = type;
    }

private:
    const Type* m_type = nullptr;
};

/**
 * Built-in primitive type
 */
class [[nodiscard]] AstBuiltInType final : public AstType {
public:
    /**
     * Construct an AstBuiltInType node
     */
    constexpr AstBuiltInType(
        const llvm::SMRange range,
        const TokenKind tokenKind
    )
    : AstType(AstKind::BuiltInType, range)
    , m_tokenKind(tokenKind) {}

    /// LLVM RTTI support to check if given node is an AstBuiltInType
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::BuiltInType;
    }

    /// Get the tokenKind
    [[nodiscard]] constexpr auto getTokenKind() const -> TokenKind {
        return m_tokenKind;
    }

private:
    TokenKind m_tokenKind;
};

/**
 * Pointer type
 */
class [[nodiscard]] AstPointerType final : public AstType {
public:
    /**
     * Construct an AstPointerType node
     */
    constexpr AstPointerType(
        const llvm::SMRange range,
        AstType* typeExpr
    )
    : AstType(AstKind::PointerType, range)
    , m_typeExpr(typeExpr) {}

    /// LLVM RTTI support to check if given node is an AstPointerType
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::PointerType;
    }

    /// Get the typeExpr
    [[nodiscard]] constexpr auto getTypeExpr() const -> AstType* {
        return m_typeExpr;
    }

private:
    AstType* m_typeExpr;
};

/**
 * Reference type
 */
class [[nodiscard]] AstReferenceType final : public AstType {
public:
    /**
     * Construct an AstReferenceType node
     */
    constexpr AstReferenceType(
        const llvm::SMRange range,
        AstType* typeExpr
    )
    : AstType(AstKind::ReferenceType, range)
    , m_typeExpr(typeExpr) {}

    /// LLVM RTTI support to check if given node is an AstReferenceType
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::ReferenceType;
    }

    /// Get the typeExpr
    [[nodiscard]] constexpr auto getTypeExpr() const -> AstType* {
        return m_typeExpr;
    }

private:
    AstType* m_typeExpr;
};

// -----------------------------------------------------------------------------
// Stmt nodes
// -----------------------------------------------------------------------------

/**
 * Abstract base for all statement nodes
 */
class [[nodiscard]] AstStmt : public AstRoot {
protected:
    using AstRoot::AstRoot;

public:
    /// LLVM RTTI support to check if given node is an AstStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() >= AstKind::StmtList && ast->getKind() <= AstKind::IfStmt;
    }

};

/**
 * List of statements
 */
class [[nodiscard]] AstStmtList final : public AstStmt {
public:
    /**
     * Construct an AstStmtList node
     */
    constexpr AstStmtList(
        const llvm::SMRange range,
        const std::span<AstStmt*> stmts,
        const std::span<AstDecl*> decls
    )
    : AstStmt(AstKind::StmtList, range)
    , m_stmts(stmts)
    , m_decls(decls) {}

    /// LLVM RTTI support to check if given node is an AstStmtList
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::StmtList;
    }

    /// Get the stmts
    [[nodiscard]] constexpr auto getStmts() const -> std::span<AstStmt*> {
        return m_stmts;
    }

    /// Get the decls
    [[nodiscard]] constexpr auto getDecls() const -> std::span<AstDecl*> {
        return m_decls;
    }

private:
    std::span<AstStmt*> m_stmts;
    std::span<AstDecl*> m_decls;
};

/**
 * Empty statement
 */
class [[nodiscard]] AstEmptyStmt final : public AstStmt {
public:
    /**
     * Construct an AstEmptyStmt node
     */
    constexpr explicit AstEmptyStmt(
        const llvm::SMRange range
    )
    : AstStmt(AstKind::EmptyStmt, range) {}

    /// LLVM RTTI support to check if given node is an AstEmptyStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::EmptyStmt;
    }

};

/**
 * DIM variable declaration statement
 */
class [[nodiscard]] AstDimStmt final : public AstStmt {
public:
    /**
     * Construct an AstDimStmt node
     */
    constexpr AstDimStmt(
        const llvm::SMRange range,
        const std::span<AstVarDecl*> decls
    )
    : AstStmt(AstKind::DimStmt, range)
    , m_decls(decls) {}

    /// LLVM RTTI support to check if given node is an AstDimStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::DimStmt;
    }

    /// Get the decls
    [[nodiscard]] constexpr auto getDecls() const -> std::span<AstVarDecl*> {
        return m_decls;
    }

private:
    std::span<AstVarDecl*> m_decls;
};

/**
 * Expression statement
 */
class [[nodiscard]] AstExprStmt final : public AstStmt {
public:
    /**
     * Construct an AstExprStmt node
     */
    constexpr AstExprStmt(
        const llvm::SMRange range,
        AstExpr* expr
    )
    : AstStmt(AstKind::ExprStmt, range)
    , m_expr(expr) {}

    /// LLVM RTTI support to check if given node is an AstExprStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::ExprStmt;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

private:
    AstExpr* m_expr;
};

/**
 * Forward declaration statement
 */
class [[nodiscard]] AstDeclareStmt final : public AstStmt {
public:
    /**
     * Construct an AstDeclareStmt node
     */
    constexpr AstDeclareStmt(
        const llvm::SMRange range,
        AstFuncDecl* decl
    )
    : AstStmt(AstKind::DeclareStmt, range)
    , m_decl(decl) {}

    /// LLVM RTTI support to check if given node is an AstDeclareStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::DeclareStmt;
    }

    /// Get the decl
    [[nodiscard]] constexpr auto getDecl() const -> AstFuncDecl* {
        return m_decl;
    }

private:
    AstFuncDecl* m_decl;
};

/**
 * External linkage block
 */
class [[nodiscard]] AstExternStmt final : public AstStmt {
public:
    /**
     * Construct an AstExternStmt node
     */
    constexpr AstExternStmt(
        const llvm::SMRange range,
        AstStmtList* stmtList
    )
    : AstStmt(AstKind::ExternStmt, range)
    , m_stmtList(stmtList) {}

    /// LLVM RTTI support to check if given node is an AstExternStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::ExternStmt;
    }

    /// Get the stmtList
    [[nodiscard]] constexpr auto getStmtList() const -> AstStmtList* {
        return m_stmtList;
    }

private:
    AstStmtList* m_stmtList;
};

/**
 * Assignment statement
 */
class [[nodiscard]] AstAssignStmt final : public AstStmt {
public:
    /**
     * Construct an AstAssignStmt node
     */
    constexpr AstAssignStmt(
        const llvm::SMRange range,
        AstExpr* assignee,
        AstExpr* expr
    )
    : AstStmt(AstKind::AssignStmt, range)
    , m_assignee(assignee)
    , m_expr(expr) {}

    /// LLVM RTTI support to check if given node is an AstAssignStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::AssignStmt;
    }

    /// Get the assignee
    [[nodiscard]] constexpr auto getAssignee() const -> AstExpr* {
        return m_assignee;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

private:
    AstExpr* m_assignee;
    AstExpr* m_expr;
};

/**
 * Function or subroutine definition
 */
class [[nodiscard]] AstFuncStmt final : public AstStmt {
public:
    /**
     * Construct an AstFuncStmt node
     */
    constexpr AstFuncStmt(
        const llvm::SMRange range,
        AstFuncDecl* decl,
        AstStmtList* stmtList
    )
    : AstStmt(AstKind::FuncStmt, range)
    , m_decl(decl)
    , m_stmtList(stmtList) {}

    /// LLVM RTTI support to check if given node is an AstFuncStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::FuncStmt;
    }

    /// Get the decl
    [[nodiscard]] constexpr auto getDecl() const -> AstFuncDecl* {
        return m_decl;
    }

    /// Get the stmtList
    [[nodiscard]] constexpr auto getStmtList() const -> AstStmtList* {
        return m_stmtList;
    }

private:
    AstFuncDecl* m_decl;
    AstStmtList* m_stmtList;
};

/**
 * Return statement
 */
class [[nodiscard]] AstReturnStmt final : public AstStmt {
public:
    /**
     * Construct an AstReturnStmt node
     */
    constexpr AstReturnStmt(
        const llvm::SMRange range,
        AstExpr* expr
    )
    : AstStmt(AstKind::ReturnStmt, range)
    , m_expr(expr) {}

    /// LLVM RTTI support to check if given node is an AstReturnStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::ReturnStmt;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

private:
    AstExpr* m_expr;
};

/**
 * IF statement
 */
class [[nodiscard]] AstIfStmt final : public AstStmt {
public:
    /**
     * Construct an AstIfStmt node
     */
    constexpr AstIfStmt(
        const llvm::SMRange range,
        AstExpr* condition,
        AstStmt* thenStmt,
        AstStmt* elseStmt
    )
    : AstStmt(AstKind::IfStmt, range)
    , m_condition(condition)
    , m_thenStmt(thenStmt)
    , m_elseStmt(elseStmt) {}

    /// LLVM RTTI support to check if given node is an AstIfStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::IfStmt;
    }

    /// Get the condition
    [[nodiscard]] constexpr auto getCondition() const -> AstExpr* {
        return m_condition;
    }

    /// Get the thenStmt
    [[nodiscard]] constexpr auto getThenStmt() const -> AstStmt* {
        return m_thenStmt;
    }

    /// Get the elseStmt
    [[nodiscard]] constexpr auto getElseStmt() const -> AstStmt* {
        return m_elseStmt;
    }

private:
    AstExpr* m_condition;
    AstStmt* m_thenStmt;
    AstStmt* m_elseStmt;
};

// -----------------------------------------------------------------------------
// Decl nodes
// -----------------------------------------------------------------------------

/**
 * Abstract base for all declaration nodes
 */
class [[nodiscard]] AstDecl : public AstRoot {
protected:
    /**
     * Construct an AstDecl node
     */
    constexpr AstDecl(
        const AstKind kind,
        const llvm::SMRange range,
        const llvm::StringRef name
    )
    : AstRoot(kind, range)
    , m_name(name) {}

public:
    /// LLVM RTTI support to check if given node is an AstDecl
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() >= AstKind::ImportDecl && ast->getKind() <= AstKind::FuncParamDecl;
    }

    /// Get the name
    [[nodiscard]] constexpr auto getName() const -> llvm::StringRef {
        return m_name;
    }

    /// Get the type
    [[nodiscard]] constexpr auto getType() const -> const Type* {
        return m_type;
    }

    /// Set the type
    void setType(const Type* type) {
        m_type = type;
    }

private:
    llvm::StringRef m_name;
    const Type* m_type = nullptr;
};

/**
 * Import declaration
 */
class [[nodiscard]] AstImportDecl final : public AstDecl {
public:
    /**
     * Construct an AstImportDecl node
     */
    constexpr AstImportDecl(
        const llvm::SMRange range,
        const llvm::StringRef name
    )
    : AstDecl(AstKind::ImportDecl, range, name) {}

    /// LLVM RTTI support to check if given node is an AstImportDecl
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::ImportDecl;
    }

};

/**
 * Variable declaration
 */
class [[nodiscard]] AstVarDecl final : public AstDecl {
public:
    /**
     * Construct an AstVarDecl node
     */
    constexpr AstVarDecl(
        const llvm::SMRange range,
        const llvm::StringRef name,
        AstType* typeExpr,
        AstExpr* expr
    )
    : AstDecl(AstKind::VarDecl, range, name)
    , m_typeExpr(typeExpr)
    , m_expr(expr) {}

    /// LLVM RTTI support to check if given node is an AstVarDecl
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::VarDecl;
    }

    /// Get the typeExpr
    [[nodiscard]] constexpr auto getTypeExpr() const -> AstType* {
        return m_typeExpr;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

private:
    AstType* m_typeExpr;
    AstExpr* m_expr;
};

/**
 * Function or subroutine declaration
 */
class [[nodiscard]] AstFuncDecl final : public AstDecl {
public:
    /**
     * Construct an AstFuncDecl node
     */
    constexpr AstFuncDecl(
        const llvm::SMRange range,
        const llvm::StringRef name,
        const std::span<AstFuncParamDecl*> params,
        AstType* retTypeExpr
    )
    : AstDecl(AstKind::FuncDecl, range, name)
    , m_params(params)
    , m_retTypeExpr(retTypeExpr) {}

    /// LLVM RTTI support to check if given node is an AstFuncDecl
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::FuncDecl;
    }

    /// Get the params
    [[nodiscard]] constexpr auto getParams() const -> std::span<AstFuncParamDecl*> {
        return m_params;
    }

    /// Get the retTypeExpr
    [[nodiscard]] constexpr auto getRetTypeExpr() const -> AstType* {
        return m_retTypeExpr;
    }

    /// Get the impl
    [[nodiscard]] constexpr auto getImpl() const -> AstFuncStmt* {
        return m_impl;
    }

    /// Set the impl
    void setImpl(AstFuncStmt* impl) {
        m_impl = impl;
    }

private:
    std::span<AstFuncParamDecl*> m_params;
    AstType* m_retTypeExpr;
    AstFuncStmt* m_impl = nullptr;
};

/**
 * Function parameter declaration
 */
class [[nodiscard]] AstFuncParamDecl final : public AstDecl {
public:
    /**
     * Construct an AstFuncParamDecl node
     */
    constexpr AstFuncParamDecl(
        const llvm::SMRange range,
        const llvm::StringRef name,
        AstType* typeExpr,
        const bool isVarArg
    )
    : AstDecl(AstKind::FuncParamDecl, range, name)
    , m_typeExpr(typeExpr)
    , m_isVarArg(isVarArg) {}

    /// LLVM RTTI support to check if given node is an AstFuncParamDecl
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::FuncParamDecl;
    }

    /// Get the typeExpr
    [[nodiscard]] constexpr auto getTypeExpr() const -> AstType* {
        return m_typeExpr;
    }

    /// Get the isVarArg
    [[nodiscard]] constexpr auto getIsVarArg() const -> bool {
        return m_isVarArg;
    }

private:
    AstType* m_typeExpr;
    bool m_isVarArg;
};

// -----------------------------------------------------------------------------
// Expr nodes
// -----------------------------------------------------------------------------

/**
 * Abstract base for all expression nodes
 */
class [[nodiscard]] AstExpr : public AstRoot {
protected:
    using AstRoot::AstRoot;

public:
    /// LLVM RTTI support to check if given node is an AstExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() >= AstKind::VariableExpr && ast->getKind() <= AstKind::MemberExpr;
    }

    /// Get the type
    [[nodiscard]] constexpr auto getType() const -> const Type* {
        return m_type;
    }

    /// Set the type
    void setType(const Type* type) {
        m_type = type;
    }

private:
    const Type* m_type = nullptr;
};

/**
 * Variable expression
 */
class [[nodiscard]] AstVariableExpr final : public AstExpr {
public:
    /**
     * Construct an AstVariableExpr node
     */
    constexpr AstVariableExpr(
        const llvm::SMRange range,
        const llvm::StringRef name
    )
    : AstExpr(AstKind::VariableExpr, range)
    , m_name(name) {}

    /// LLVM RTTI support to check if given node is an AstVariableExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::VariableExpr;
    }

    /// Get the name
    [[nodiscard]] constexpr auto getName() const -> llvm::StringRef {
        return m_name;
    }

private:
    llvm::StringRef m_name;
};

/**
 * CALL expression
 */
class [[nodiscard]] AstCallExpr final : public AstExpr {
public:
    /**
     * Construct an AstCallExpr node
     */
    constexpr AstCallExpr(
        const llvm::SMRange range,
        AstExpr* callee,
        const std::span<AstExpr*> args
    )
    : AstExpr(AstKind::CallExpr, range)
    , m_callee(callee)
    , m_args(args) {}

    /// LLVM RTTI support to check if given node is an AstCallExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::CallExpr;
    }

    /// Get the callee
    [[nodiscard]] constexpr auto getCallee() const -> AstExpr* {
        return m_callee;
    }

    /// Get the args
    [[nodiscard]] constexpr auto getArgs() const -> std::span<AstExpr*> {
        return m_args;
    }

private:
    AstExpr* m_callee;
    std::span<AstExpr*> m_args;
};

/**
 * Literal expression
 */
class [[nodiscard]] AstLiteralExpr final : public AstExpr {
public:
    /**
     * Construct an AstLiteralExpr node
     */
    constexpr AstLiteralExpr(
        const llvm::SMRange range,
        const LiteralValue value
    )
    : AstExpr(AstKind::LiteralExpr, range)
    , m_value(value) {}

    /// LLVM RTTI support to check if given node is an AstLiteralExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::LiteralExpr;
    }

    /// Get the value
    [[nodiscard]] constexpr auto getValue() const -> LiteralValue {
        return m_value;
    }

private:
    LiteralValue m_value;
};

/**
 * Unary expression
 */
class [[nodiscard]] AstUnaryExpr final : public AstExpr {
public:
    /**
     * Construct an AstUnaryExpr node
     */
    constexpr AstUnaryExpr(
        const llvm::SMRange range,
        AstExpr* expr,
        const TokenKind tokenKind
    )
    : AstExpr(AstKind::UnaryExpr, range)
    , m_expr(expr)
    , m_tokenKind(tokenKind) {}

    /// LLVM RTTI support to check if given node is an AstUnaryExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::UnaryExpr;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

    /// Get the tokenKind
    [[nodiscard]] constexpr auto getTokenKind() const -> TokenKind {
        return m_tokenKind;
    }

private:
    AstExpr* m_expr;
    TokenKind m_tokenKind;
};

/**
 * Binary expression
 */
class [[nodiscard]] AstBinaryExpr final : public AstExpr {
public:
    /**
     * Construct an AstBinaryExpr node
     */
    constexpr AstBinaryExpr(
        const llvm::SMRange range,
        AstExpr* left,
        AstExpr* right,
        const TokenKind tokenKind
    )
    : AstExpr(AstKind::BinaryExpr, range)
    , m_left(left)
    , m_right(right)
    , m_tokenKind(tokenKind) {}

    /// LLVM RTTI support to check if given node is an AstBinaryExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::BinaryExpr;
    }

    /// Get the left
    [[nodiscard]] constexpr auto getLeft() const -> AstExpr* {
        return m_left;
    }

    /// Get the right
    [[nodiscard]] constexpr auto getRight() const -> AstExpr* {
        return m_right;
    }

    /// Get the tokenKind
    [[nodiscard]] constexpr auto getTokenKind() const -> TokenKind {
        return m_tokenKind;
    }

private:
    AstExpr* m_left;
    AstExpr* m_right;
    TokenKind m_tokenKind;
};

/**
 * CAST expression
 */
class [[nodiscard]] AstCastExpr final : public AstExpr {
public:
    /**
     * Construct an AstCastExpr node
     */
    constexpr AstCastExpr(
        const llvm::SMRange range,
        AstExpr* expr,
        AstType* typeExpr,
        const bool isImplicit
    )
    : AstExpr(AstKind::CastExpr, range)
    , m_expr(expr)
    , m_typeExpr(typeExpr)
    , m_isImplicit(isImplicit) {}

    /// LLVM RTTI support to check if given node is an AstCastExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::CastExpr;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

    /// Get the typeExpr
    [[nodiscard]] constexpr auto getTypeExpr() const -> AstType* {
        return m_typeExpr;
    }

    /// Get the isImplicit
    [[nodiscard]] constexpr auto getIsImplicit() const -> bool {
        return m_isImplicit;
    }

private:
    AstExpr* m_expr;
    AstType* m_typeExpr;
    bool m_isImplicit;
};

/**
 * DEREFERENCE expression
 */
class [[nodiscard]] AstDereferenceExpr final : public AstExpr {
public:
    /**
     * Construct an AstDereferenceExpr node
     */
    constexpr AstDereferenceExpr(
        const llvm::SMRange range,
        AstExpr* expr
    )
    : AstExpr(AstKind::DereferenceExpr, range)
    , m_expr(expr) {}

    /// LLVM RTTI support to check if given node is an AstDereferenceExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::DereferenceExpr;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

private:
    AstExpr* m_expr;
};

/**
 * ADDRESS OF expression
 */
class [[nodiscard]] AstAddressOfExpr final : public AstExpr {
public:
    /**
     * Construct an AstAddressOfExpr node
     */
    constexpr AstAddressOfExpr(
        const llvm::SMRange range,
        AstExpr* expr
    )
    : AstExpr(AstKind::AddressOfExpr, range)
    , m_expr(expr) {}

    /// LLVM RTTI support to check if given node is an AstAddressOfExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::AddressOfExpr;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

private:
    AstExpr* m_expr;
};

/**
 * Member expression
 */
class [[nodiscard]] AstMemberExpr final : public AstExpr {
public:
    /**
     * Construct an AstMemberExpr node
     */
    constexpr AstMemberExpr(
        const llvm::SMRange range,
        AstExpr* expr,
        AstExpr* member,
        const TokenKind tokenKind
    )
    : AstExpr(AstKind::MemberExpr, range)
    , m_expr(expr)
    , m_member(member)
    , m_tokenKind(tokenKind) {}

    /// LLVM RTTI support to check if given node is an AstMemberExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot*  ast) -> bool {
        return ast->getKind() == AstKind::MemberExpr;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

    /// Get the member
    [[nodiscard]] constexpr auto getMember() const -> AstExpr* {
        return m_member;
    }

    /// Get the tokenKind
    [[nodiscard]] constexpr auto getTokenKind() const -> TokenKind {
        return m_tokenKind;
    }

private:
    AstExpr* m_expr;
    AstExpr* m_member;
    TokenKind m_tokenKind;
};

} // namespace lbc
