//
// This file is part of lbc project
// https://github.com/albeva/lbc
//
// DO NOT MODIFY. This file is AUTO GENERATED.
//
// This file is generated by "lbc-ast-def" from "Ast.td"
// clang-format off
#pragma once
#include "pch.hpp"
#include "../Symbol/LiteralValue.hpp"
#include "Lexer/TokenKind.hpp"

namespace lbc {

class Type;

/**
 * Enumerates all concrete AST node kinds.
 * Values are ordered by group for efficient range-based membership checks.
 */
enum class AstKind : std::uint8_t {
    Module,
    BuiltInType,
    PointerType,
    ReferenceType,
    StmtList,
    ExprStmt,
    DeclareStmt,
    FuncStmt,
    ReturnStmt,
    DimStmt,
    AssignStmt,
    IfStmt,
    VarDecl,
    FuncDecl,
    FuncParamDecl,
    VarExpr,
    CallExpr,
    LiteralExpr,
    UnaryExpr,
    BinaryExpr,
    MemberExpr,
};

// -----------------------------------------------------------------------------
// Forward Declarations
// -----------------------------------------------------------------------------

class AstRoot;
class AstModule;
class AstType;
class AstBuiltInType;
class AstPointerType;
class AstReferenceType;
class AstStmt;
class AstStmtList;
class AstExprStmt;
class AstDeclareStmt;
class AstFuncStmt;
class AstReturnStmt;
class AstDimStmt;
class AstAssignStmt;
class AstIfStmt;
class AstDecl;
class AstVarDecl;
class AstFuncDecl;
class AstFuncParamDecl;
class AstExpr;
class AstVarExpr;
class AstCallExpr;
class AstLiteralExpr;
class AstUnaryExpr;
class AstBinaryExpr;
class AstMemberExpr;

// -----------------------------------------------------------------------------
// Root nodes
// -----------------------------------------------------------------------------

/**
 * The root AST node
 */
class [[nodiscard]] AstRoot {
public:
    NO_COPY_AND_MOVE(AstRoot)

protected:
    /**
     * Construct an AstRoot node
     */
    constexpr AstRoot(
        const AstKind kind,
        const llvm::SMRange range
    )
    : m_kind(kind)
    , m_range(range) {}

public:
    /// LLVM RTTI support to check if given node is an AstRoot
    [[nodiscard]] static constexpr auto classof(const AstRoot* /* ast */) -> bool {
        return true;
    }

    /// Number of AST leaf nodes
    static constexpr std::size_t NODE_COUNT = 21;

    /// Get the kind discriminator for this node
    [[nodiscard]] constexpr auto getKind() const -> AstKind {
        return m_kind;
    }

    /// Get ast node class name
    [[nodiscard]] constexpr auto getClassName() const -> llvm::StringRef {
        const auto index = static_cast<std::size_t>(m_kind);
        return kClassNames.at(index);
    }

    /// Get the range
    [[nodiscard]] constexpr auto getRange() const -> llvm::SMRange {
        return m_range;
    }

    /// Get the next
    [[nodiscard]] constexpr auto getNext() const -> AstRoot* {
        return m_next;
    }

    /// Set the next
    void setNext(AstRoot* next) {
        m_next = next;
    }

    /**
     * Test function
     */
     [[nodiscard]] auto hasNextSet() const -> bool {
         return m_next != nullptr;
     }

private:
    AstKind m_kind;
    llvm::SMRange m_range;
    AstRoot* m_next = nullptr;
    static constexpr std::array<llvm::StringRef, NODE_COUNT> kClassNames {
        "AstModule",
        "AstBuiltInType",
        "AstPointerType",
        "AstReferenceType",
        "AstStmtList",
        "AstExprStmt",
        "AstDeclareStmt",
        "AstFuncStmt",
        "AstReturnStmt",
        "AstDimStmt",
        "AstAssignStmt",
        "AstIfStmt",
        "AstVarDecl",
        "AstFuncDecl",
        "AstFuncParamDecl",
        "AstVarExpr",
        "AstCallExpr",
        "AstLiteralExpr",
        "AstUnaryExpr",
        "AstBinaryExpr",
        "AstMemberExpr"
    };
};

/**
 * Program module node
 */
class [[nodiscard]] AstModule final : public AstRoot {
public:
    /**
     * Construct an AstModule node
     */
    constexpr AstModule(
        const llvm::SMRange range,
        AstStmtList* stmtList
    )
    : AstRoot(AstKind::Module, range)
    , m_stmtList(stmtList) {}

    /// LLVM RTTI support to check if given node is an AstModule
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::Module;
    }

    /// Get the stmtList
    [[nodiscard]] constexpr auto getStmtList() const -> AstStmtList* {
        return m_stmtList;
    }

private:
    AstStmtList* m_stmtList;
};

// -----------------------------------------------------------------------------
// Type nodes
// -----------------------------------------------------------------------------

/**
 * Abstract base for all type expression nodes
 */
class [[nodiscard]] AstType : public AstRoot {
protected:
    using AstRoot::AstRoot;

public:
    /// LLVM RTTI support to check if given node is an AstType
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() >= AstKind::BuiltInType && ast->getKind() <= AstKind::ReferenceType;
    }

    /// Get the type
    [[nodiscard]] constexpr auto getType() const -> const Type* {
        return m_type;
    }

    /// Set the type
    void setType(const Type* type) {
        m_type = type;
    }

private:
    const Type* m_type = nullptr;
};

/**
 * Built-in primitive type
 */
class [[nodiscard]] AstBuiltInType final : public AstType {
public:
    /**
     * Construct an AstBuiltInType node
     */
    constexpr AstBuiltInType(
        const llvm::SMRange range,
        const TokenKind tokenKind
    )
    : AstType(AstKind::BuiltInType, range)
    , m_tokenKind(tokenKind) {}

    /// LLVM RTTI support to check if given node is an AstBuiltInType
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::BuiltInType;
    }

    /// Get the tokenKind
    [[nodiscard]] constexpr auto getTokenKind() const -> TokenKind {
        return m_tokenKind;
    }

private:
    TokenKind m_tokenKind;
};

/**
 * Pointer type
 */
class [[nodiscard]] AstPointerType final : public AstType {
public:
    /**
     * Construct an AstPointerType node
     */
    constexpr AstPointerType(
        const llvm::SMRange range,
        AstType* typeExpr
    )
    : AstType(AstKind::PointerType, range)
    , m_typeExpr(typeExpr) {}

    /// LLVM RTTI support to check if given node is an AstPointerType
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::PointerType;
    }

    /// Get the typeExpr
    [[nodiscard]] constexpr auto getTypeExpr() const -> AstType* {
        return m_typeExpr;
    }

private:
    AstType* m_typeExpr;
};

/**
 * Reference type
 */
class [[nodiscard]] AstReferenceType final : public AstType {
public:
    /**
     * Construct an AstReferenceType node
     */
    constexpr AstReferenceType(
        const llvm::SMRange range,
        AstType* typeExpr
    )
    : AstType(AstKind::ReferenceType, range)
    , m_typeExpr(typeExpr) {}

    /// LLVM RTTI support to check if given node is an AstReferenceType
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::ReferenceType;
    }

    /// Get the typeExpr
    [[nodiscard]] constexpr auto getTypeExpr() const -> AstType* {
        return m_typeExpr;
    }

private:
    AstType* m_typeExpr;
};

// -----------------------------------------------------------------------------
// Stmt nodes
// -----------------------------------------------------------------------------

/**
 * Abstract base for all statement nodes
 */
class [[nodiscard]] AstStmt : public AstRoot {
protected:
    using AstRoot::AstRoot;

public:
    /// LLVM RTTI support to check if given node is an AstStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() >= AstKind::StmtList && ast->getKind() <= AstKind::IfStmt;
    }

};

/**
 * List of statements
 */
class [[nodiscard]] AstStmtList final : public AstStmt {
public:
    /**
     * Construct an AstStmtList node
     */
    constexpr AstStmtList(
        const llvm::SMRange range,
        const std::span<AstDecl*> decls,
        const std::span<AstStmt*> stmts
    )
    : AstStmt(AstKind::StmtList, range)
    , m_decls(decls)
    , m_stmts(stmts) {}

    /// LLVM RTTI support to check if given node is an AstStmtList
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::StmtList;
    }

    /// Get the decls
    [[nodiscard]] constexpr auto getDecls() const -> std::span<AstDecl*> {
        return m_decls;
    }

    /// Get the stmts
    [[nodiscard]] constexpr auto getStmts() const -> std::span<AstStmt*> {
        return m_stmts;
    }

private:
    std::span<AstDecl*> m_decls;
    std::span<AstStmt*> m_stmts;
};

/**
 * Expression statement
 */
class [[nodiscard]] AstExprStmt final : public AstStmt {
public:
    /**
     * Construct an AstExprStmt node
     */
    constexpr AstExprStmt(
        const llvm::SMRange range,
        AstExpr* expr
    )
    : AstStmt(AstKind::ExprStmt, range)
    , m_expr(expr) {}

    /// LLVM RTTI support to check if given node is an AstExprStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::ExprStmt;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

private:
    AstExpr* m_expr;
};

/**
 * Forward declaration statement
 */
class [[nodiscard]] AstDeclareStmt final : public AstStmt {
public:
    /**
     * Construct an AstDeclareStmt node
     */
    constexpr AstDeclareStmt(
        const llvm::SMRange range,
        AstFuncDecl* decl
    )
    : AstStmt(AstKind::DeclareStmt, range)
    , m_decl(decl) {}

    /// LLVM RTTI support to check if given node is an AstDeclareStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::DeclareStmt;
    }

    /// Get the decl
    [[nodiscard]] constexpr auto getDecl() const -> AstFuncDecl* {
        return m_decl;
    }

private:
    AstFuncDecl* m_decl;
};

/**
 * Function or subroutine definition
 */
class [[nodiscard]] AstFuncStmt final : public AstStmt {
public:
    /**
     * Construct an AstFuncStmt node
     */
    constexpr AstFuncStmt(
        const llvm::SMRange range,
        AstFuncDecl* decl,
        AstStmtList* stmtList
    )
    : AstStmt(AstKind::FuncStmt, range)
    , m_decl(decl)
    , m_stmtList(stmtList) {}

    /// LLVM RTTI support to check if given node is an AstFuncStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::FuncStmt;
    }

    /// Get the decl
    [[nodiscard]] constexpr auto getDecl() const -> AstFuncDecl* {
        return m_decl;
    }

    /// Get the stmtList
    [[nodiscard]] constexpr auto getStmtList() const -> AstStmtList* {
        return m_stmtList;
    }

private:
    AstFuncDecl* m_decl;
    AstStmtList* m_stmtList;
};

/**
 * Return statement
 */
class [[nodiscard]] AstReturnStmt final : public AstStmt {
public:
    /**
     * Construct an AstReturnStmt node
     */
    constexpr AstReturnStmt(
        const llvm::SMRange range,
        AstExpr* expr
    )
    : AstStmt(AstKind::ReturnStmt, range)
    , m_expr(expr) {}

    /// LLVM RTTI support to check if given node is an AstReturnStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::ReturnStmt;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

private:
    AstExpr* m_expr;
};

/**
 * DIM variable declaration statement
 */
class [[nodiscard]] AstDimStmt final : public AstStmt {
public:
    /**
     * Construct an AstDimStmt node
     */
    constexpr AstDimStmt(
        const llvm::SMRange range,
        const std::span<AstVarDecl*> decls
    )
    : AstStmt(AstKind::DimStmt, range)
    , m_decls(decls) {}

    /// LLVM RTTI support to check if given node is an AstDimStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::DimStmt;
    }

    /// Get the decls
    [[nodiscard]] constexpr auto getDecls() const -> std::span<AstVarDecl*> {
        return m_decls;
    }

private:
    std::span<AstVarDecl*> m_decls;
};

/**
 * Assignment statement
 */
class [[nodiscard]] AstAssignStmt final : public AstStmt {
public:
    /**
     * Construct an AstAssignStmt node
     */
    constexpr AstAssignStmt(
        const llvm::SMRange range,
        AstExpr* assignee,
        AstExpr* expr
    )
    : AstStmt(AstKind::AssignStmt, range)
    , m_assignee(assignee)
    , m_expr(expr) {}

    /// LLVM RTTI support to check if given node is an AstAssignStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::AssignStmt;
    }

    /// Get the assignee
    [[nodiscard]] constexpr auto getAssignee() const -> AstExpr* {
        return m_assignee;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

private:
    AstExpr* m_assignee;
    AstExpr* m_expr;
};

/**
 * IF statement
 */
class [[nodiscard]] AstIfStmt final : public AstStmt {
public:
    /**
     * Construct an AstIfStmt node
     */
    constexpr AstIfStmt(
        const llvm::SMRange range,
        AstExpr* condition,
        AstStmt* thenStmt,
        AstStmt* elseStmt
    )
    : AstStmt(AstKind::IfStmt, range)
    , m_condition(condition)
    , m_thenStmt(thenStmt)
    , m_elseStmt(elseStmt) {}

    /// LLVM RTTI support to check if given node is an AstIfStmt
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::IfStmt;
    }

    /// Get the condition
    [[nodiscard]] constexpr auto getCondition() const -> AstExpr* {
        return m_condition;
    }

    /// Get the thenStmt
    [[nodiscard]] constexpr auto getThenStmt() const -> AstStmt* {
        return m_thenStmt;
    }

    /// Get the elseStmt
    [[nodiscard]] constexpr auto getElseStmt() const -> AstStmt* {
        return m_elseStmt;
    }

private:
    AstExpr* m_condition;
    AstStmt* m_thenStmt;
    AstStmt* m_elseStmt;
};

// -----------------------------------------------------------------------------
// Decl nodes
// -----------------------------------------------------------------------------

/**
 * Abstract base for all declaration nodes
 */
class [[nodiscard]] AstDecl : public AstRoot {
protected:
    /**
     * Construct an AstDecl node
     */
    constexpr AstDecl(
        const AstKind kind,
        const llvm::SMRange range,
        const llvm::StringRef name
    )
    : AstRoot(kind, range)
    , m_name(name) {}

public:
    /// LLVM RTTI support to check if given node is an AstDecl
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() >= AstKind::VarDecl && ast->getKind() <= AstKind::FuncParamDecl;
    }

    /// Get the name
    [[nodiscard]] constexpr auto getName() const -> llvm::StringRef {
        return m_name;
    }

    /// Get the type
    [[nodiscard]] constexpr auto getType() const -> const Type* {
        return m_type;
    }

    /// Set the type
    void setType(const Type* type) {
        m_type = type;
    }

private:
    llvm::StringRef m_name;
    const Type* m_type = nullptr;
};

/**
 * Variable declaration
 */
class [[nodiscard]] AstVarDecl final : public AstDecl {
public:
    /**
     * Construct an AstVarDecl node
     */
    constexpr AstVarDecl(
        const llvm::SMRange range,
        const llvm::StringRef name,
        AstType* typeExpr,
        AstExpr* expr
    )
    : AstDecl(AstKind::VarDecl, range, name)
    , m_typeExpr(typeExpr)
    , m_expr(expr) {}

    /// LLVM RTTI support to check if given node is an AstVarDecl
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::VarDecl;
    }

    /// Get the typeExpr
    [[nodiscard]] constexpr auto getTypeExpr() const -> AstType* {
        return m_typeExpr;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

private:
    AstType* m_typeExpr;
    AstExpr* m_expr;
};

/**
 * Function or subroutine declaration
 */
class [[nodiscard]] AstFuncDecl final : public AstDecl {
public:
    /**
     * Construct an AstFuncDecl node
     */
    constexpr AstFuncDecl(
        const llvm::SMRange range,
        const llvm::StringRef name,
        const std::span<AstFuncParamDecl*> params,
        AstType* retTypeExpr
    )
    : AstDecl(AstKind::FuncDecl, range, name)
    , m_params(params)
    , m_retTypeExpr(retTypeExpr) {}

    /// LLVM RTTI support to check if given node is an AstFuncDecl
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::FuncDecl;
    }

    /// Get the params
    [[nodiscard]] constexpr auto getParams() const -> std::span<AstFuncParamDecl*> {
        return m_params;
    }

    /// Get the retTypeExpr
    [[nodiscard]] constexpr auto getRetTypeExpr() const -> AstType* {
        return m_retTypeExpr;
    }

    /// Get the impl
    [[nodiscard]] constexpr auto getImpl() const -> AstFuncStmt* {
        return m_impl;
    }

    /// Set the impl
    void setImpl(AstFuncStmt* impl) {
        m_impl = impl;
    }

private:
    std::span<AstFuncParamDecl*> m_params;
    AstType* m_retTypeExpr;
    AstFuncStmt* m_impl = nullptr;
};

/**
 * Function parameter declaration
 */
class [[nodiscard]] AstFuncParamDecl final : public AstDecl {
public:
    /**
     * Construct an AstFuncParamDecl node
     */
    constexpr AstFuncParamDecl(
        const llvm::SMRange range,
        const llvm::StringRef name,
        AstType* typeExpr
    )
    : AstDecl(AstKind::FuncParamDecl, range, name)
    , m_typeExpr(typeExpr) {}

    /// LLVM RTTI support to check if given node is an AstFuncParamDecl
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::FuncParamDecl;
    }

    /// Get the typeExpr
    [[nodiscard]] constexpr auto getTypeExpr() const -> AstType* {
        return m_typeExpr;
    }

private:
    AstType* m_typeExpr;
};

// -----------------------------------------------------------------------------
// Expr nodes
// -----------------------------------------------------------------------------

/**
 * Abstract base for all expression nodes
 */
class [[nodiscard]] AstExpr : public AstRoot {
protected:
    using AstRoot::AstRoot;

public:
    /// LLVM RTTI support to check if given node is an AstExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() >= AstKind::VarExpr && ast->getKind() <= AstKind::MemberExpr;
    }

    /// Get the type
    [[nodiscard]] constexpr auto getType() const -> const Type* {
        return m_type;
    }

    /// Set the type
    void setType(const Type* type) {
        m_type = type;
    }

private:
    const Type* m_type = nullptr;
};

/**
 * Variable expression
 */
class [[nodiscard]] AstVarExpr final : public AstExpr {
public:
    /**
     * Construct an AstVarExpr node
     */
    constexpr AstVarExpr(
        const llvm::SMRange range,
        const llvm::StringRef name
    )
    : AstExpr(AstKind::VarExpr, range)
    , m_name(name) {}

    /// LLVM RTTI support to check if given node is an AstVarExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::VarExpr;
    }

    /// Get the name
    [[nodiscard]] constexpr auto getName() const -> llvm::StringRef {
        return m_name;
    }

private:
    llvm::StringRef m_name;
};

/**
 * CALL expression
 */
class [[nodiscard]] AstCallExpr final : public AstExpr {
public:
    /**
     * Construct an AstCallExpr node
     */
    constexpr AstCallExpr(
        const llvm::SMRange range,
        AstExpr* callee,
        const std::span<AstExpr*> args
    )
    : AstExpr(AstKind::CallExpr, range)
    , m_callee(callee)
    , m_args(args) {}

    /// LLVM RTTI support to check if given node is an AstCallExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::CallExpr;
    }

    /// Get the callee
    [[nodiscard]] constexpr auto getCallee() const -> AstExpr* {
        return m_callee;
    }

    /// Get the args
    [[nodiscard]] constexpr auto getArgs() const -> std::span<AstExpr*> {
        return m_args;
    }

private:
    AstExpr* m_callee;
    std::span<AstExpr*> m_args;
};

/**
 * Literal expression
 */
class [[nodiscard]] AstLiteralExpr final : public AstExpr {
public:
    /**
     * Construct an AstLiteralExpr node
     */
    constexpr AstLiteralExpr(
        const llvm::SMRange range,
        const LiteralValue value
    )
    : AstExpr(AstKind::LiteralExpr, range)
    , m_value(value) {}

    /// LLVM RTTI support to check if given node is an AstLiteralExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::LiteralExpr;
    }

    /// Get the value
    [[nodiscard]] constexpr auto getValue() const -> LiteralValue {
        return m_value;
    }

private:
    LiteralValue m_value;
};

/**
 * Unary expression
 */
class [[nodiscard]] AstUnaryExpr final : public AstExpr {
public:
    /**
     * Construct an AstUnaryExpr node
     */
    constexpr AstUnaryExpr(
        const llvm::SMRange range,
        AstExpr* expr,
        const TokenKind op
    )
    : AstExpr(AstKind::UnaryExpr, range)
    , m_expr(expr)
    , m_op(op) {}

    /// LLVM RTTI support to check if given node is an AstUnaryExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::UnaryExpr;
    }

    /// Get the expr
    [[nodiscard]] constexpr auto getExpr() const -> AstExpr* {
        return m_expr;
    }

    /// Get the op
    [[nodiscard]] constexpr auto getOp() const -> TokenKind {
        return m_op;
    }

private:
    AstExpr* m_expr;
    TokenKind m_op;
};

/**
 * Binary expression
 */
class [[nodiscard]] AstBinaryExpr final : public AstExpr {
public:
    /**
     * Construct an AstBinaryExpr node
     */
    constexpr AstBinaryExpr(
        const llvm::SMRange range,
        AstExpr* left,
        AstExpr* right,
        const TokenKind op
    )
    : AstExpr(AstKind::BinaryExpr, range)
    , m_left(left)
    , m_right(right)
    , m_op(op) {}

    /// LLVM RTTI support to check if given node is an AstBinaryExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::BinaryExpr;
    }

    /// Get the left
    [[nodiscard]] constexpr auto getLeft() const -> AstExpr* {
        return m_left;
    }

    /// Get the right
    [[nodiscard]] constexpr auto getRight() const -> AstExpr* {
        return m_right;
    }

    /// Get the op
    [[nodiscard]] constexpr auto getOp() const -> TokenKind {
        return m_op;
    }

private:
    AstExpr* m_left;
    AstExpr* m_right;
    TokenKind m_op;
};

/**
 * Member access
 */
class [[nodiscard]] AstMemberExpr final : public AstExpr {
public:
    /**
     * Construct an AstMemberExpr node
     */
    constexpr AstMemberExpr(
        const llvm::SMRange range,
        AstExpr* left,
        AstExpr* right,
        const TokenKind op
    )
    : AstExpr(AstKind::MemberExpr, range)
    , m_left(left)
    , m_right(right)
    , m_op(op) {}

    /// LLVM RTTI support to check if given node is an AstMemberExpr
    [[nodiscard]] static constexpr auto classof(const AstRoot* ast) -> bool {
        return ast->getKind() == AstKind::MemberExpr;
    }

    /// Get the left
    [[nodiscard]] constexpr auto getLeft() const -> AstExpr* {
        return m_left;
    }

    /// Get the right
    [[nodiscard]] constexpr auto getRight() const -> AstExpr* {
        return m_right;
    }

    /// Get the op
    [[nodiscard]] constexpr auto getOp() const -> TokenKind {
        return m_op;
    }

private:
    AstExpr* m_left;
    AstExpr* m_right;
    TokenKind m_op;
};

} // namespace lbc
