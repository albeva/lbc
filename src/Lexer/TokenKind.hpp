//
// This file is part of lbc project
// https://github.com/albeva/lbc
//
// DO NOT MODIFY. This file is AUTOGENERATED.
//
// This file is generated by "lbc-tokens-def" from "TokenKind.td"
// clang-format off
#pragma once
#include "pch.hpp"

namespace lbc {

/**
 * TokenKind represents the value of a scanned token
 */
struct TokenKind final {
    /**
     * Value backing TokenKind. This is intentionally implicitly defined in scope
     */
    enum Value : std::uint8_t { // NOLINT(*-use-enum-class)
        Invalid,
        EndOfFile,
        EndOfStmt,
        Identifier,
        IntegerLiteral,
        FloatLiteral,
        StringLiteral,
        BooleanLiteral,
        NullLiteral,
        Comma,
        ParenClose,
        BracketOpen,
        BracketClose,
        Ellipsis,
        ParenOpen,
        MemberAccess,
        PointerAccess,
        AddressOf,
        Dereference,
        Negate,
        LogicalNot,
        Is,
        As,
        Multiply,
        Divide,
        Modulus,
        Plus,
        Minus,
        Equal,
        NotEqual,
        LessThan,
        LessOrEqual,
        GreaterThan,
        GreaterOrEqual,
        LogicalAnd,
        LogicalOr,
        Assign,
        ConditionAnd,
        AlignOf,
        Any,
        Const,
        Continue,
        Declare,
        Dim,
        Do,
        Else,
        End,
        Exit,
        Extern,
        False,
        For,
        Function,
        If,
        Import,
        Loop,
        Next,
        Null,
        Ptr,
        Ref,
        Rem,
        Return,
        SizeOf,
        Step,
        Sub,
        Then,
        To,
        True,
        TypeKw,
        TypeOf,
        Until,
        While,
        BoolType,
        ZString,
        Byte,
        UByte,
        Short,
        UShort,
        Integer,
        UInteger,
        Long,
        ULong,
        Single,
        Double,
    };

    /**
     * Token group represents the generic class of token
     */
    enum class Group : std::uint8_t {
        General,
        Literal,
        Symbol,
        Operator,
        Keyword,
        Type,
    };

    /**
     * Operator category classification
     */
    enum class Category : std::uint8_t {
        Invalid,
        Arithmetic,
        Assignment,
        Call,
        Cast,
        Comparison,
        Logical,
        Memory,
    };

    /**
     * Total number of token kinds
     */
    static constexpr std::size_t COUNT = 83;

    constexpr TokenKind() = default;

    constexpr TokenKind(const Value value) // NOLINT(*-explicit-conversions)
    : m_value(value) { }

    /**
     * Return the underlying Value enum
     */
    [[nodiscard]] constexpr auto value() const {
        return m_value;
    }

    constexpr auto operator=(const Value value) -> TokenKind& {
        m_value = value;
        return *this;
    }

    [[nodiscard]] constexpr auto operator==(const TokenKind& value) const -> bool = default;

    [[nodiscard]] constexpr auto operator==(const Value value) const -> bool {
        return m_value == value;
    }

    /**
     * Check if this token matches any of the given kinds
     */
    template <typename... Tkns>
    [[nodiscard]] constexpr auto isOneOf(Tkns... tkn) const -> bool {
        return ((m_value == TokenKind(tkn).m_value) || ...);
    }

    /**
     * Check if this token belongs to the General group
     */
    [[nodiscard]] constexpr auto isGeneral() const -> bool {
        return m_value >= Invalid && m_value <= Identifier;
    }

    /**
     * Check if this token belongs to the Literal group
     */
    [[nodiscard]] constexpr auto isLiteral() const -> bool {
        return m_value >= IntegerLiteral && m_value <= NullLiteral;
    }

    /**
     * Check if this token belongs to the Symbol group
     */
    [[nodiscard]] constexpr auto isSymbol() const -> bool {
        return m_value >= Comma && m_value <= Ellipsis;
    }

    /**
     * Check if this token belongs to the Operator group
     */
    [[nodiscard]] constexpr auto isOperator() const -> bool {
        return m_value >= ParenOpen && m_value <= ConditionAnd;
    }

    /**
     * Check if this token belongs to the Keyword group
     */
    [[nodiscard]] constexpr auto isKeyword() const -> bool {
        return m_value >= AlignOf && m_value <= While;
    }

    /**
     * Check if this token belongs to the Type group
     */
    [[nodiscard]] constexpr auto isType() const -> bool {
        return m_value >= BoolType && m_value <= Double;
    }

    /**
     * Return the operator category, or Invalid for non-operators
     */
    [[nodiscard]] constexpr auto getCategory() const -> Category {
        switch (m_value) {
            case Negate:
            case Multiply:
            case Divide:
            case Modulus:
            case Plus:
            case Minus:
                return Category::Arithmetic;
            case Assign:
                return Category::Assignment;
            case ParenOpen:
                return Category::Call;
            case As:
                return Category::Cast;
            case Is:
            case Equal:
            case NotEqual:
            case LessThan:
            case LessOrEqual:
            case GreaterThan:
            case GreaterOrEqual:
                return Category::Comparison;
            case LogicalNot:
            case LogicalAnd:
            case LogicalOr:
            case ConditionAnd:
                return Category::Logical;
            case MemberAccess:
            case PointerAccess:
            case AddressOf:
            case Dereference:
                return Category::Memory;
            default:
                return Category::Invalid;
        }
    }

    /**
     * Check if this is an Arithmetic operator
     */
    [[nodiscard]] constexpr auto isArithmetic() const -> bool {
        return getCategory() == Category::Arithmetic;
    }

    /**
     * Check if this is an Assignment operator
     */
    [[nodiscard]] constexpr auto isAssignment() const -> bool {
        return getCategory() == Category::Assignment;
    }

    /**
     * Check if this is a Call operator
     */
    [[nodiscard]] constexpr auto isCall() const -> bool {
        return getCategory() == Category::Call;
    }

    /**
     * Check if this is a Cast operator
     */
    [[nodiscard]] constexpr auto isCast() const -> bool {
        return getCategory() == Category::Cast;
    }

    /**
     * Check if this is a Comparison operator
     */
    [[nodiscard]] constexpr auto isComparison() const -> bool {
        return getCategory() == Category::Comparison;
    }

    /**
     * Check if this is a Logical operator
     */
    [[nodiscard]] constexpr auto isLogical() const -> bool {
        return getCategory() == Category::Logical;
    }

    /**
     * Check if this is a Memory operator
     */
    [[nodiscard]] constexpr auto isMemory() const -> bool {
        return getCategory() == Category::Memory;
    }

    /**
     * Return operator precedence (higher binds tighter), or 0 for non-operators
     */
    [[nodiscard]] constexpr auto getPrecedence() const -> int {
        // NOLINTBEGIN(*-magic-numbers)
        switch (m_value) {
            case ParenOpen:
                return 14;
            case MemberAccess:
            case PointerAccess:
                return 13;
            case AddressOf:
            case Dereference:
                return 12;
            case Negate:
            case LogicalNot:
                return 11;
            case Is:
            case As:
                return 10;
            case Multiply:
            case Divide:
                return 9;
            case Modulus:
                return 8;
            case Plus:
            case Minus:
                return 7;
            case Equal:
            case NotEqual:
                return 6;
            case LessThan:
            case LessOrEqual:
            case GreaterThan:
            case GreaterOrEqual:
                return 5;
            case LogicalAnd:
                return 4;
            case LogicalOr:
                return 3;
            case Assign:
                return 2;
            case ConditionAnd:
                return 1;
            default:
                return 0;
        }
        // NOLINTEND(*-magic-numbers)
    }

    /**
     * Check if this is a binary operator
     */
    [[nodiscard]] constexpr auto isBinary() const -> bool {
        switch (m_value) {
            case MemberAccess:
            case PointerAccess:
            case Multiply:
            case Divide:
            case Modulus:
            case Plus:
            case Minus:
            case Equal:
            case NotEqual:
            case LessThan:
            case LessOrEqual:
            case GreaterThan:
            case GreaterOrEqual:
            case LogicalAnd:
            case LogicalOr:
            case Assign:
            case ConditionAnd:
                return true;
            default:
                return false;
        }
    }

    /**
     * Check if this is a unary operator
     */
    [[nodiscard]] constexpr auto isUnary() const -> bool {
        return isOperator() && !isBinary();
    }

    /**
     * Check if this operator is left-associative
     */
    [[nodiscard]] constexpr auto isLeftAssociative() const -> bool {
        switch (m_value) {
            case MemberAccess:
            case PointerAccess:
            case LogicalNot:
            case Multiply:
            case Divide:
            case Modulus:
            case Plus:
            case Minus:
            case Equal:
            case NotEqual:
            case LessThan:
            case LessOrEqual:
            case GreaterThan:
            case GreaterOrEqual:
            case LogicalAnd:
            case LogicalOr:
            case Assign:
            case ConditionAnd:
                return true;
            default:
                return false;
        }
    }

    /**
     * Check if this operator is right-associative
     */
    [[nodiscard]] constexpr auto isRightAssociative() const -> bool {
        return isOperator() && !isLeftAssociative();
    }

    /**
     * Return the string representation of this token
     */
    [[nodiscard]] constexpr auto string() const -> llvm::StringRef {
        switch (m_value) {
            case Invalid: return "<Invalid>";
            case EndOfFile: return "<End-Of-File>";
            case EndOfStmt: return "<End-Of-Stmt>";
            case Identifier: return "<Identifier>";
            case IntegerLiteral: return "<Integer-Literal>";
            case FloatLiteral: return "<Float-Literal>";
            case StringLiteral: return "<String-Literal>";
            case BooleanLiteral: return "<Boolean-Literal>";
            case NullLiteral: return "<Null-Literal>";
            case Comma: return ",";
            case ParenClose: return ")";
            case BracketOpen: return "[";
            case BracketClose: return "]";
            case Ellipsis: return "...";
            case ParenOpen: return "(";
            case MemberAccess: return ".";
            case PointerAccess: return "->";
            case AddressOf: return "@";
            case Dereference: return "*";
            case Negate: return "-";
            case LogicalNot: return "NOT";
            case Is: return "IS";
            case As: return "AS";
            case Multiply: return "*";
            case Divide: return "/";
            case Modulus: return "MOD";
            case Plus: return "+";
            case Minus: return "-";
            case Equal: return "=";
            case NotEqual: return "<>";
            case LessThan: return "<";
            case LessOrEqual: return "<=";
            case GreaterThan: return ">";
            case GreaterOrEqual: return ">=";
            case LogicalAnd: return "AND";
            case LogicalOr: return "OR";
            case Assign: return "=";
            case ConditionAnd: return ",";
            case AlignOf: return "ALIGNOF";
            case Any: return "ANY";
            case Const: return "CONST";
            case Continue: return "CONTINUE";
            case Declare: return "DECLARE";
            case Dim: return "DIM";
            case Do: return "DO";
            case Else: return "ELSE";
            case End: return "END";
            case Exit: return "EXIT";
            case Extern: return "EXTERN";
            case False: return "FALSE";
            case For: return "FOR";
            case Function: return "FUNCTION";
            case If: return "IF";
            case Import: return "IMPORT";
            case Loop: return "LOOP";
            case Next: return "NEXT";
            case Null: return "NULL";
            case Ptr: return "PTR";
            case Ref: return "REF";
            case Rem: return "REM";
            case Return: return "RETURN";
            case SizeOf: return "SIZEOF";
            case Step: return "STEP";
            case Sub: return "SUB";
            case Then: return "THEN";
            case To: return "TO";
            case True: return "TRUE";
            case TypeKw: return "TYPE";
            case TypeOf: return "TYPEOF";
            case Until: return "UNTIL";
            case While: return "WHILE";
            case BoolType: return "BOOL";
            case ZString: return "ZSTRING";
            case Byte: return "BYTE";
            case UByte: return "UBYTE";
            case Short: return "SHORT";
            case UShort: return "USHORT";
            case Integer: return "INTEGER";
            case UInteger: return "UINTEGER";
            case Long: return "LONG";
            case ULong: return "ULONG";
            case Single: return "SINGLE";
            case Double: return "DOUBLE";
        }
        std::unreachable();
    }

    /**
     * Return all General tokens
     */
    [[nodiscard]] static consteval auto allGenerals() -> std::array<TokenKind, 4> { // NOLINT(*-magic-numbers)
        return {Invalid, EndOfFile, EndOfStmt, Identifier};
    }

    /**
     * Return all Literal tokens
     */
    [[nodiscard]] static consteval auto allLiterals() -> std::array<TokenKind, 5> { // NOLINT(*-magic-numbers)
        return {IntegerLiteral, FloatLiteral, StringLiteral, BooleanLiteral, NullLiteral};
    }

    /**
     * Return all Symbol tokens
     */
    [[nodiscard]] static consteval auto allSymbols() -> std::array<TokenKind, 5> { // NOLINT(*-magic-numbers)
        return {Comma, ParenClose, BracketOpen, BracketClose, Ellipsis};
    }

    /**
     * Return all Operator tokens
     */
    [[nodiscard]] static consteval auto allOperators() -> std::array<TokenKind, 24> { // NOLINT(*-magic-numbers)
        return {ParenOpen, MemberAccess, PointerAccess, AddressOf, Dereference, Negate, LogicalNot, Is, As, Multiply, Divide, Modulus, Plus, Minus, Equal, NotEqual, LessThan, LessOrEqual, GreaterThan, GreaterOrEqual, LogicalAnd, LogicalOr, Assign, ConditionAnd};
    }

    /**
     * Return all Keyword tokens
     */
    [[nodiscard]] static consteval auto allKeywords() -> std::array<TokenKind, 33> { // NOLINT(*-magic-numbers)
        return {AlignOf, Any, Const, Continue, Declare, Dim, Do, Else, End, Exit, Extern, False, For, Function, If, Import, Loop, Next, Null, Ptr, Ref, Rem, Return, SizeOf, Step, Sub, Then, To, True, TypeKw, TypeOf, Until, While};
    }

    /**
     * Return all Type tokens
     */
    [[nodiscard]] static consteval auto allTypes() -> std::array<TokenKind, 12> { // NOLINT(*-magic-numbers)
        return {BoolType, ZString, Byte, UByte, Short, UShort, Integer, UInteger, Long, ULong, Single, Double};
    }

    /**
     * Return all operators that look like keywords
     */
    [[nodiscard]] static consteval auto allOperatorKeywords() -> std::array<TokenKind, 6> { // NOLINT(*-magic-numbers)
        return { LogicalNot, Is, As, Modulus, LogicalAnd, LogicalOr };
    }

    private:
    Value m_value;
};
} // namespace lbc

/**
 * Support hashing TokenKind
 */
template <>
struct std::hash<lbc::TokenKind> final {
    [[nodiscard]] auto operator()(const lbc::TokenKind& value) const noexcept -> std::size_t {
        return std::hash<std::underlying_type_t<lbc::TokenKind::Value>> {}(value.value());
    }
};

/**
 * Support using TokenKind with std::print and std::format
 */
template <>
struct std::formatter<lbc::TokenKind, char> final {
    constexpr static auto parse(std::format_parse_context& ctx) {
        return ctx.begin();
    }

    auto format(const lbc::TokenKind& value, auto& ctx) const {
        return std::format_to(ctx.out(), "{}", value.string());
    }
};
