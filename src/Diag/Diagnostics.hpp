//
// This file is part of lbc project
// https://github.com/albeva/lbc
//
// DO NOT MODIFY. This file is AUTO GENERATED.
//
// This file is generated by "lbc-diag-def" from "Diagnostics.td"
// clang-format off
#pragma once
#include "pch.hpp"
namespace lbc {

/**
 * DiagKind identifies a specific diagnostic and carries its static metadata
 */
struct DiagKind final {
    /**
     * Diagnostic identifier
     */
    enum Value : std::uint8_t { // NOLINT(*-use-enum-class)
        notImplemented,
        invalid,
        unterminatedString,
        invalidNumber,
        unexpected,
        expected,
        redefinition,
        circularDependency,
    };

    /**
     * Diagnostic subsystem
     */
    enum class Category : std::uint8_t {
        System,
        Lex,
        Parse,
        Sema,
    };

    /**
     * Total number of diagnostic kinds
     */
    static constexpr std::size_t COUNT = 8;

    /**
     * Default-construct to an uninitialized diagnostic kind
     */
    constexpr DiagKind() = default;

    /**
     * Implicitly convert from a Value enumerator
     */
    constexpr DiagKind(const Value value) // NOLINT(*-explicit-conversions)
    : m_value(value) { }

    /**
     * Return the underlying Value enum
     */
    [[nodiscard]] constexpr auto value() const {
        return m_value;
    }

    /**
     * Compare two DiagKind values for equality
     */
    [[nodiscard]] constexpr auto operator==(const DiagKind& other) const -> bool = default;

    /**
     * Compare against a raw Value enumerator
     */
    [[nodiscard]] constexpr auto operator==(const Value value) const -> bool {
        return m_value == value;
    }

    /**
     * Return the category for this diagnostic
     */
    [[nodiscard]] constexpr auto getCategory() const -> Category {
        switch (m_value) {
            case notImplemented:
                return Category::System;
            case invalid:
            case unterminatedString:
            case invalidNumber:
                return Category::Lex;
            case unexpected:
            case expected:
                return Category::Parse;
            case redefinition:
            case circularDependency:
                return Category::Sema;
        }
        std::unreachable();
    }

    /**
     * Return the severity for this diagnostic
     */
    [[nodiscard]] constexpr auto getSeverity() const -> llvm::SourceMgr::DiagKind {
        switch (m_value) {
            case notImplemented:
            case invalid:
            case unterminatedString:
            case invalidNumber:
            case unexpected:
            case expected:
            case redefinition:
            case circularDependency:
                return llvm::SourceMgr::DK_Error;
        }
        std::unreachable();
    }

    /**
     * Return the diagnostic code string
     */
    [[nodiscard]] constexpr auto getCode() const -> llvm::StringRef {
        switch (m_value) {
            case notImplemented: return "E0001";
            case invalid: return "E0100";
            case unterminatedString: return "E0101";
            case invalidNumber: return "E0102";
            case unexpected: return "E0200";
            case expected: return "E0201";
            case redefinition: return "E0301";
            case circularDependency: return "E0302";
        }
        std::unreachable();
    }

    /**
     * Return all Error diagnostics
     */
    [[nodiscard]] static consteval auto allErrors() -> std::array<DiagKind, 8> { // NOLINT(*-magic-numbers)
        return { notImplemented, invalid, unterminatedString, invalidNumber, unexpected, expected, redefinition, circularDependency };
    }

private:
    /// Underlying enumerator
    Value m_value;
};
} // namespace lbc

/**
 * Support using DiagKind with std::print and std::format
 */
template <>
struct std::formatter<lbc::DiagKind, char> final {
    constexpr static auto parse(std::format_parse_context& ctx) {
        return ctx.begin();
    }

    auto format(const lbc::DiagKind& value, auto& ctx) const {
        return std::format_to(ctx.out(), "{}", value.getCode());
    }
};

namespace lbc {

/**
 * Encapsulate a diagnostic kind and its formatted message
 */
using DiagMessage = std::pair<DiagKind, std::string>;

namespace diagnostics {
    // -------------------------------------------------------------------------
    // System
    // -------------------------------------------------------------------------

    /// Create notImplemented message
    [[nodiscard]] inline auto notImplemented() -> DiagMessage {
        return { DiagKind::notImplemented, "Not implemented" };
    }

    // -------------------------------------------------------------------------
    // Lex
    // -------------------------------------------------------------------------

    /// Create invalid message
    [[nodiscard]] inline auto invalid() -> DiagMessage {
        return { DiagKind::invalid, "invalid input" };
    }

    /// Create unterminatedString message
    [[nodiscard]] inline auto unterminatedString() -> DiagMessage {
        return { DiagKind::unterminatedString, "unterminated string literal" };
    }

    /// Create invalidNumber message
    [[nodiscard]] inline auto invalidNumber() -> DiagMessage {
        return { DiagKind::invalidNumber, "invalid number" };
    }

    // -------------------------------------------------------------------------
    // Parse
    // -------------------------------------------------------------------------

    /// Create unexpected message
    [[nodiscard]] inline auto unexpected(const auto& found) -> DiagMessage {
        return { DiagKind::unexpected, std::format("unexpected {}", found) };
    }

    /// Create expected message
    [[nodiscard]] inline auto expected(const auto& expected, const auto& found) -> DiagMessage {
        return { DiagKind::expected, std::format("expected {}, found {}", expected, found) };
    }

    // -------------------------------------------------------------------------
    // Sema
    // -------------------------------------------------------------------------

    /// Create redefinition message
    [[nodiscard]] inline auto redefinition(const auto& name) -> DiagMessage {
        return { DiagKind::redefinition, std::format("redefinition of {}", name) };
    }

    /// Create circularDependency message
    [[nodiscard]] inline auto circularDependency(const auto& name) -> DiagMessage {
        return { DiagKind::circularDependency, std::format("circular dependency on {}", name) };
    }

}
} // namespace lbc
