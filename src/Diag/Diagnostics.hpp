//
// This file is part of lbc project
// https://github.com/albeva/lbc
//
// DO NOT MODIFY. This file is AUTO GENERATED.
//
// This file is generated by "lbc-diag-def" from "Diagnostics.td"
// clang-format off
#pragma once
#include "pch.hpp"

namespace lbc {

/**
 * DiagKind identifies a specific diagnostic and carries its static metadata
 */
struct DiagKind final {
    /**
     * Diagnostic identifier
     */
    enum Value : std::uint8_t { // NOLINT(*-use-enum-class)
        notImplemented,
        fileNotFound,
        includeNotFound,
        invalidCharacter,
        unterminatedString,
        invalidNumber,
        unexpectedToken,
        expectedToken,
        unexpectedEndOfFile,
        expectedType,
        undeclaredIdentifier,
        redefinition,
        typeMismatch,
        invalidOperands,
        tooManyArguments,
        tooFewArguments,
        returnTypeMismatch,
        unusedVariable,
        unusedParameter,
        declaredHere,
        previousDefinition,
        invalidModule,
        codegenFailure,
    };

    /**
     * Diagnostic subsystem
     */
    enum class Category : std::uint8_t {
        System,
        Lex,
        Parse,
        Sema,
        IR,
        LLVM,
    };

    /**
     * Total number of diagnostic kinds
     */
    static constexpr std::size_t COUNT = 23;

    /**
     * Default-construct to an uninitialized diagnostic kind
     */
    constexpr DiagKind() = default;

    /**
     * Implicitly convert from a Value enumerator
     */
    constexpr DiagKind(const Value value) // NOLINT(*-explicit-conversions)
    : m_value(value) { }

    /**
     * Return the underlying Value enum
     */
    [[nodiscard]] constexpr auto value() const {
        return m_value;
    }

    /**
     * Compare two DiagKind values for equality
     */
    [[nodiscard]] constexpr auto operator==(const DiagKind& other) const -> bool = default;

    /**
     * Compare against a raw Value enumerator
     */
    [[nodiscard]] constexpr auto operator==(const Value value) const -> bool {
        return m_value == value;
    }

    /**
     * Return the category for this diagnostic
     */
    [[nodiscard]] constexpr auto getCategory() const -> Category {
        switch (m_value) {
            case notImplemented:
            case fileNotFound:
            case includeNotFound:
                return Category::System;
            case invalidCharacter:
            case unterminatedString:
            case invalidNumber:
                return Category::Lex;
            case unexpectedToken:
            case expectedToken:
            case unexpectedEndOfFile:
            case expectedType:
                return Category::Parse;
            case undeclaredIdentifier:
            case redefinition:
            case typeMismatch:
            case invalidOperands:
            case tooManyArguments:
            case tooFewArguments:
            case returnTypeMismatch:
            case unusedVariable:
            case unusedParameter:
            case declaredHere:
            case previousDefinition:
                return Category::Sema;
            case invalidModule:
                return Category::IR;
            case codegenFailure:
                return Category::LLVM;
        }
        std::unreachable();
    }

    /**
     * Return the severity for this diagnostic
     */
    [[nodiscard]] constexpr auto getSeverity() const -> llvm::SourceMgr::DiagKind {
        switch (m_value) {
            case notImplemented:
            case fileNotFound:
            case includeNotFound:
            case invalidCharacter:
            case unterminatedString:
            case invalidNumber:
            case unexpectedToken:
            case expectedToken:
            case unexpectedEndOfFile:
            case expectedType:
            case undeclaredIdentifier:
            case redefinition:
            case typeMismatch:
            case invalidOperands:
            case tooManyArguments:
            case tooFewArguments:
            case returnTypeMismatch:
            case invalidModule:
            case codegenFailure:
                return llvm::SourceMgr::DK_Error;
            case unusedVariable:
            case unusedParameter:
                return llvm::SourceMgr::DK_Warning;
            case declaredHere:
            case previousDefinition:
                return llvm::SourceMgr::DK_Note;
        }
        std::unreachable();
    }

    /**
     * Return the diagnostic code string
     */
    [[nodiscard]] constexpr auto getCode() const -> llvm::StringRef {
        switch (m_value) {
            case notImplemented: return "E0001";
            case fileNotFound: return "E0002";
            case includeNotFound: return "E0003";
            case invalidCharacter: return "E0100";
            case unterminatedString: return "E0101";
            case invalidNumber: return "E0102";
            case unexpectedToken: return "E0200";
            case expectedToken: return "E0201";
            case unexpectedEndOfFile: return "E0202";
            case expectedType: return "E0203";
            case undeclaredIdentifier: return "E0300";
            case redefinition: return "E0301";
            case typeMismatch: return "E0302";
            case invalidOperands: return "E0303";
            case tooManyArguments: return "E0304";
            case tooFewArguments: return "E0305";
            case returnTypeMismatch: return "E0306";
            case unusedVariable: return "unused-variable";
            case unusedParameter: return "unused-parameter";
            case declaredHere: return "N0001";
            case previousDefinition: return "N0002";
            case invalidModule: return "E0400";
            case codegenFailure: return "E0500";
        }
        std::unreachable();
    }

    /**
     * Return all Error diagnostics
     */
    [[nodiscard]] static consteval auto allErrors() -> std::array<DiagKind, 19> { // NOLINT(*-magic-numbers)
        return {notImplemented, fileNotFound, includeNotFound, invalidCharacter, unterminatedString, invalidNumber, unexpectedToken, expectedToken, unexpectedEndOfFile, expectedType, undeclaredIdentifier, redefinition, typeMismatch, invalidOperands, tooManyArguments, tooFewArguments, returnTypeMismatch, invalidModule, codegenFailure};
    }

    /**
     * Return all Warning diagnostics
     */
    [[nodiscard]] static consteval auto allWarnings() -> std::array<DiagKind, 2> { // NOLINT(*-magic-numbers)
        return {unusedVariable, unusedParameter};
    }

    /**
     * Return all Note diagnostics
     */
    [[nodiscard]] static consteval auto allNotes() -> std::array<DiagKind, 2> { // NOLINT(*-magic-numbers)
        return {declaredHere, previousDefinition};
    }

    private:
    /// Underlying enumerator
    Value m_value;
};
} // namespace lbc

/**
 * Support using DiagKind with std::print and std::format
 */
template <>
struct std::formatter<lbc::DiagKind, char> final {
    constexpr static auto parse(std::format_parse_context& ctx) {
        return ctx.begin();
    }

    auto format(const lbc::DiagKind& value, auto& ctx) const {
        return std::format_to(ctx.out(), "{}", value.getCode());
    }
};

namespace lbc {


/**
 * Encapsulate a diagnostic kind and its formatted message
 */
using DiagMessage = std::pair<DiagKind, std::string>;

namespace Diagnostics {
    template<typename T>
    concept Loggable = std::formattable<T, char>;

    // -------------------------------------------------------------------------
    // System
    // -------------------------------------------------------------------------

    /// Create notImplemented message
    [[nodiscard]] inline auto notImplemented() -> DiagMessage {
        return { DiagKind::notImplemented, "Not implemented" };
    }

    /// Create fileNotFound message
    [[nodiscard]] inline auto fileNotFound(const Loggable auto& path) -> DiagMessage {
        return { DiagKind::fileNotFound, std::format("file not found: {}", path) };
    }

    /// Create includeNotFound message
    [[nodiscard]] inline auto includeNotFound(const Loggable auto& path) -> DiagMessage {
        return { DiagKind::includeNotFound, std::format("included file not found: {}", path) };
    }

    // -------------------------------------------------------------------------
    // Lex
    // -------------------------------------------------------------------------

    /// Create invalidCharacter message
    [[nodiscard]] inline auto invalidCharacter(const Loggable auto& character) -> DiagMessage {
        return { DiagKind::invalidCharacter, std::format("invalid character {}", character) };
    }

    /// Create unterminatedString message
    [[nodiscard]] inline auto unterminatedString() -> DiagMessage {
        return { DiagKind::unterminatedString, "unterminated string literal" };
    }

    /// Create invalidNumber message
    [[nodiscard]] inline auto invalidNumber(const Loggable auto& text) -> DiagMessage {
        return { DiagKind::invalidNumber, std::format("invalid number literal {}", text) };
    }

    // -------------------------------------------------------------------------
    // Parse
    // -------------------------------------------------------------------------

    /// Create unexpectedToken message
    [[nodiscard]] inline auto unexpectedToken(const Loggable auto& found) -> DiagMessage {
        return { DiagKind::unexpectedToken, std::format("found unexpected input {}", found) };
    }

    /// Create expectedToken message
    [[nodiscard]] inline auto expectedToken(const Loggable auto& expected, const Loggable auto& found) -> DiagMessage {
        return { DiagKind::expectedToken, std::format("expected {}, found {}", expected, found) };
    }

    /// Create unexpectedEndOfFile message
    [[nodiscard]] inline auto unexpectedEndOfFile() -> DiagMessage {
        return { DiagKind::unexpectedEndOfFile, "unexpected end of file" };
    }

    /// Create expectedType message
    [[nodiscard]] inline auto expectedType() -> DiagMessage {
        return { DiagKind::expectedType, "expected type expression" };
    }

    // -------------------------------------------------------------------------
    // Sema
    // -------------------------------------------------------------------------

    /// Create undeclaredIdentifier message
    [[nodiscard]] inline auto undeclaredIdentifier(const Loggable auto& name) -> DiagMessage {
        return { DiagKind::undeclaredIdentifier, std::format("use of undeclared identifier {}", name) };
    }

    /// Create redefinition message
    [[nodiscard]] inline auto redefinition(const Loggable auto& name) -> DiagMessage {
        return { DiagKind::redefinition, std::format("redefinition of {}", name) };
    }

    /// Create typeMismatch message
    [[nodiscard]] inline auto typeMismatch(const Loggable auto& from, const Loggable auto& to) -> DiagMessage {
        return { DiagKind::typeMismatch, std::format("cannot convert {} to {}", from, to) };
    }

    /// Create invalidOperands message
    [[nodiscard]] inline auto invalidOperands(const Loggable auto& op, const Loggable auto& left, const Loggable auto& right) -> DiagMessage {
        return { DiagKind::invalidOperands, std::format("invalid operands to {}: {} and {}", op, left, right) };
    }

    /// Create tooManyArguments message
    [[nodiscard]] inline auto tooManyArguments(const int expected, const int got) -> DiagMessage {
        return { DiagKind::tooManyArguments, std::format("too many arguments: expected {}, got {}", expected, got) };
    }

    /// Create tooFewArguments message
    [[nodiscard]] inline auto tooFewArguments(const int expected, const int got) -> DiagMessage {
        return { DiagKind::tooFewArguments, std::format("too few arguments: expected {}, got {}", expected, got) };
    }

    /// Create returnTypeMismatch message
    [[nodiscard]] inline auto returnTypeMismatch(const Loggable auto& found, const Loggable auto& expected) -> DiagMessage {
        return { DiagKind::returnTypeMismatch, std::format("return type {} does not match expected {}", found, expected) };
    }

    /// Create unusedVariable message
    [[nodiscard]] inline auto unusedVariable(const Loggable auto& name) -> DiagMessage {
        return { DiagKind::unusedVariable, std::format("unused variable {}", name) };
    }

    /// Create unusedParameter message
    [[nodiscard]] inline auto unusedParameter(const Loggable auto& name) -> DiagMessage {
        return { DiagKind::unusedParameter, std::format("unused parameter {}", name) };
    }

    /// Create declaredHere message
    [[nodiscard]] inline auto declaredHere(const Loggable auto& name) -> DiagMessage {
        return { DiagKind::declaredHere, std::format("{} declared here", name) };
    }

    /// Create previousDefinition message
    [[nodiscard]] inline auto previousDefinition(const Loggable auto& name) -> DiagMessage {
        return { DiagKind::previousDefinition, std::format("previous definition of {} is here", name) };
    }

    // -------------------------------------------------------------------------
    // IR
    // -------------------------------------------------------------------------

    /// Create invalidModule message
    [[nodiscard]] inline auto invalidModule(const Loggable auto& name, const Loggable auto& reason) -> DiagMessage {
        return { DiagKind::invalidModule, std::format("failed to load module {}: {}", name, reason) };
    }

    // -------------------------------------------------------------------------
    // LLVM
    // -------------------------------------------------------------------------

    /// Create codegenFailure message
    [[nodiscard]] inline auto codegenFailure(const Loggable auto& reason) -> DiagMessage {
        return { DiagKind::codegenFailure, std::format("code generation failed: {}", reason) };
    }

}
} // namespace lbc
