//
// This file is part of lbc project
// https://github.com/albeva/lbc
//
// DO NOT MODIFY. This file is AUTO GENERATED.
//
// This file is generated by "lbc-diag-def" from "Diagnostics.td"
// clang-format off
#pragma once
#include "pch.hpp"
namespace lbc {

/**
 * DiagKind identifies a specific diagnostic and carries its static metadata
 */
struct DiagKind final {
    /**
     * Diagnostic identifier
     */
    enum Value : std::uint8_t { // NOLINT(*-use-enum-class)
        notImplemented,
        invalid,
        unterminatedString,
        invalidNumber,
        unexpected,
        expected,
        undeclaredIdentifier,
        useBeforeDefinition,
        redefinition,
        circularDependency,
        typeMismatch,
        invalidOperands,
        tooManyArguments,
        tooFewArguments,
        uninitializedReference,
        referenceToReference,
        pointerToReference,
        nullVariable,
        nonAddressableExpr,
    };

    /**
     * Diagnostic subsystem
     */
    enum class Category : std::uint8_t {
        System,
        Lex,
        Parse,
        Sema,
    };

    /**
     * Total number of diagnostic kinds
     */
    static constexpr std::size_t COUNT = 19;

    /**
     * Default-construct to an uninitialized diagnostic kind
     */
    constexpr DiagKind() = default;

    /**
     * Implicitly convert from a Value enumerator
     */
    constexpr DiagKind(const Value value) // NOLINT(*-explicit-conversions)
    : m_value(value) { }

    /**
     * Return the underlying Value enum
     */
    [[nodiscard]] constexpr auto value() const {
        return m_value;
    }

    /**
     * Compare two DiagKind values for equality
     */
    [[nodiscard]] constexpr auto operator==(const DiagKind& other) const -> bool = default;

    /**
     * Compare against a raw Value enumerator
     */
    [[nodiscard]] constexpr auto operator==(const Value value) const -> bool {
        return m_value == value;
    }

    /**
     * Return the category for this diagnostic
     */
    [[nodiscard]] constexpr auto getCategory() const -> Category {
        switch (m_value) {
            case notImplemented:
                return Category::System;
            case invalid:
            case unterminatedString:
            case invalidNumber:
                return Category::Lex;
            case unexpected:
            case expected:
                return Category::Parse;
            case undeclaredIdentifier:
            case useBeforeDefinition:
            case redefinition:
            case circularDependency:
            case typeMismatch:
            case invalidOperands:
            case tooManyArguments:
            case tooFewArguments:
            case uninitializedReference:
            case referenceToReference:
            case pointerToReference:
            case nullVariable:
            case nonAddressableExpr:
                return Category::Sema;
        }
        std::unreachable();
    }

    /**
     * Return the severity for this diagnostic
     */
    [[nodiscard]] constexpr auto getSeverity() const -> llvm::SourceMgr::DiagKind {
        switch (m_value) {
            case notImplemented:
            case invalid:
            case unterminatedString:
            case invalidNumber:
            case unexpected:
            case expected:
            case undeclaredIdentifier:
            case useBeforeDefinition:
            case redefinition:
            case circularDependency:
            case typeMismatch:
            case invalidOperands:
            case tooManyArguments:
            case tooFewArguments:
            case uninitializedReference:
            case referenceToReference:
            case pointerToReference:
            case nullVariable:
            case nonAddressableExpr:
                return llvm::SourceMgr::DK_Error;
        }
        std::unreachable();
    }

    /**
     * Return the diagnostic code string
     */
    [[nodiscard]] constexpr auto getCode() const -> llvm::StringRef {
        switch (m_value) {
            case notImplemented: return "E0001";
            case invalid: return "E0100";
            case unterminatedString: return "E0101";
            case invalidNumber: return "E0102";
            case unexpected: return "E0200";
            case expected: return "E0201";
            case undeclaredIdentifier: return "E0300";
            case useBeforeDefinition: return "E0301";
            case redefinition: return "E0302";
            case circularDependency: return "E0303";
            case typeMismatch: return "E0304";
            case invalidOperands: return "E0305";
            case tooManyArguments: return "E0306";
            case tooFewArguments: return "E0307";
            case uninitializedReference: return "E0308";
            case referenceToReference: return "E0309";
            case pointerToReference: return "E0310";
            case nullVariable: return "E0311";
            case nonAddressableExpr: return "E0312";
        }
        std::unreachable();
    }

    /**
     * Return all Error diagnostics
     */
    [[nodiscard]] static consteval auto allErrors() -> std::array<DiagKind, 19> { // NOLINT(*-magic-numbers)
        return { notImplemented, invalid, unterminatedString, invalidNumber, unexpected, expected, undeclaredIdentifier, useBeforeDefinition, redefinition, circularDependency, typeMismatch, invalidOperands, tooManyArguments, tooFewArguments, uninitializedReference, referenceToReference, pointerToReference, nullVariable, nonAddressableExpr };
    }

private:
    /// Underlying enumerator
    Value m_value;
};
} // namespace lbc

/**
 * Support using DiagKind with std::print and std::format
 */
template <>
struct std::formatter<lbc::DiagKind, char> final {
    constexpr static auto parse(std::format_parse_context& ctx) {
        return ctx.begin();
    }

    auto format(const lbc::DiagKind& value, auto& ctx) const {
        return std::format_to(ctx.out(), "{}", value.getCode());
    }
};

namespace lbc {

/**
 * Encapsulate a diagnostic kind and its formatted message
 */
using DiagMessage = std::pair<DiagKind, std::string>;

namespace diagnostics {
    // -------------------------------------------------------------------------
    // System
    // -------------------------------------------------------------------------

    /// Create notImplemented message
    [[nodiscard]] inline auto notImplemented() -> DiagMessage {
        return { DiagKind::notImplemented, "Not implemented" };
    }

    // -------------------------------------------------------------------------
    // Lex
    // -------------------------------------------------------------------------

    /// Create invalid message
    [[nodiscard]] inline auto invalid() -> DiagMessage {
        return { DiagKind::invalid, "invalid input" };
    }

    /// Create unterminatedString message
    [[nodiscard]] inline auto unterminatedString() -> DiagMessage {
        return { DiagKind::unterminatedString, "unterminated string literal" };
    }

    /// Create invalidNumber message
    [[nodiscard]] inline auto invalidNumber() -> DiagMessage {
        return { DiagKind::invalidNumber, "invalid number" };
    }

    // -------------------------------------------------------------------------
    // Parse
    // -------------------------------------------------------------------------

    /// Create unexpected message
    [[nodiscard]] inline auto unexpected(const auto& found) -> DiagMessage {
        return { DiagKind::unexpected, std::format("unexpected {}", found) };
    }

    /// Create expected message
    [[nodiscard]] inline auto expected(const auto& expected, const auto& found) -> DiagMessage {
        return { DiagKind::expected, std::format("expected {}, found {}", expected, found) };
    }

    // -------------------------------------------------------------------------
    // Sema
    // -------------------------------------------------------------------------

    /// Create undeclaredIdentifier message
    [[nodiscard]] inline auto undeclaredIdentifier(const auto& name) -> DiagMessage {
        return { DiagKind::undeclaredIdentifier, std::format("use of undeclared identifier {}", name) };
    }

    /// Create useBeforeDefinition message
    [[nodiscard]] inline auto useBeforeDefinition(const auto& name) -> DiagMessage {
        return { DiagKind::useBeforeDefinition, std::format("use of identifier before definition {}", name) };
    }

    /// Create redefinition message
    [[nodiscard]] inline auto redefinition(const auto& name) -> DiagMessage {
        return { DiagKind::redefinition, std::format("redefinition of {}", name) };
    }

    /// Create circularDependency message
    [[nodiscard]] inline auto circularDependency(const auto& name) -> DiagMessage {
        return { DiagKind::circularDependency, std::format("circular dependency on {}", name) };
    }

    /// Create typeMismatch message
    [[nodiscard]] inline auto typeMismatch(const auto& from, const auto& to) -> DiagMessage {
        return { DiagKind::typeMismatch, std::format("cannot convert {} to {}", from, to) };
    }

    /// Create invalidOperands message
    [[nodiscard]] inline auto invalidOperands(const auto& op, const auto& left, const auto& right) -> DiagMessage {
        return { DiagKind::invalidOperands, std::format("invalid operands to {}: {} and {}", op, left, right) };
    }

    /// Create tooManyArguments message
    [[nodiscard]] inline auto tooManyArguments(const std::size_t expected, const std::size_t got) -> DiagMessage {
        return { DiagKind::tooManyArguments, std::format("too many arguments: expected {}, got {}", expected, got) };
    }

    /// Create tooFewArguments message
    [[nodiscard]] inline auto tooFewArguments(const std::size_t expected, const std::size_t got) -> DiagMessage {
        return { DiagKind::tooFewArguments, std::format("too few arguments: expected {}, got {}", expected, got) };
    }

    /// Create uninitializedReference message
    [[nodiscard]] inline auto uninitializedReference(const auto& name) -> DiagMessage {
        return { DiagKind::uninitializedReference, std::format("reference variable {} must be initialised", name) };
    }

    /// Create referenceToReference message
    [[nodiscard]] inline auto referenceToReference() -> DiagMessage {
        return { DiagKind::referenceToReference, "cannot create a reference to a reference" };
    }

    /// Create pointerToReference message
    [[nodiscard]] inline auto pointerToReference() -> DiagMessage {
        return { DiagKind::pointerToReference, "cannot create a pointer to a reference" };
    }

    /// Create nullVariable message
    [[nodiscard]] inline auto nullVariable() -> DiagMessage {
        return { DiagKind::nullVariable, "cannot declare a variable of type null" };
    }

    /// Create nonAddressableExpr message
    [[nodiscard]] inline auto nonAddressableExpr() -> DiagMessage {
        return { DiagKind::nonAddressableExpr, "cannot take address from expression" };
    }

}
} // namespace lbc
